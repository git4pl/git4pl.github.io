<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://git4pl.github.io</id>
    <title>PL Notes</title>
    <updated>2021-06-10T02:54:50.783Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://git4pl.github.io"/>
    <link rel="self" href="https://git4pl.github.io/atom.xml"/>
    <subtitle>积跬步至千里，积小流成江海</subtitle>
    <logo>https://git4pl.github.io/images/avatar.png</logo>
    <icon>https://git4pl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, PL Notes</rights>
    <entry>
        <title type="html"><![CDATA[探究Jetpack Compose实现原理]]></title>
        <id>https://git4pl.github.io/post/T_YU0mYZa/</id>
        <link href="https://git4pl.github.io/post/T_YU0mYZa/">
        </link>
        <updated>2021-05-07T09:24:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="整体设计原理">整体设计原理</h3>
<p>我们熟悉的 Android View 框架以 View 树的形式描述 UI，Jetpack Compose 构建 UI 也是树的形式，它在 UI 层级中的基本元素是 LayoutNode 节点。因为 Compose 是声明式 UI，需要将配置和绘制分离，同时设计算法对节点进行复用，以实现高性能。Jetpack Compose UI 框架的主要技术点大概如下：</p>
<ul>
<li>@Composable 注解函数实现 UI 的声明和配置</li>
<li>基于注解和 Composer 实现 LayoutNode 的缓存及复用，同时实现对属性变化的监听</li>
<li>LayoutNode 主要实现 UI 布局和绘制</li>
</ul>
<h3 id="compose-recompose-原理">Compose &amp; Recompose 原理</h3>
<p>使用 Jetpack Compose 构建 UI 最明显的一个特点是通过 @Composable 注解函数来声明 UI 内容，这里使用注解函数声明 UI 不能说 Compose 框架是一个注解处理器，Compose 应用了 Kotlin 编译器的新特性 —— IR extension（intermediate representation的缩写，意为中间语言），在 Kotlin 编译器的类型检测和代码生成阶段添加一些代码逻辑。@Composable 注解和 Kotlin 的 suspend 关键字类似，可以适用于函数、Lambda 或者函数类型，它会导致被注解的元素类型改变，未被注解的函数类型与注解后的相同函数类型互不兼容。</p>
<pre><code>@Composable
fun Greeting(name: String) {
    Text(text = &quot;Hello $name!&quot;)
}
</code></pre>
<p>将上面这段代码反编译后得到如下的代码内容，编译器在参数列表中增加了两个参数，在代码逻辑中也增加了很多条件判断和代码块，可见编译器做了大量的工作来实现简洁的声明式 API 调用。<br>
<img src="https://git4pl.github.io/post-images/1620379910698.png" alt="" loading="lazy"></p>
<p>从反编译的代码可以看到，编译器加入了一个叫做 Composer 的参数，这个参数就是在 Composable 函数中传递的上下文调用对象。Composer 对象将 Compose 框架里的 Composition 和 Recomposition 过程贯穿起来了，这里涉及到 Compose 框架的核心绘制机制。</p>
<p>Composer 可以理解为与 Android View 框架里的 Context 类似的对象，负责存储所有跟 Compose UI 有关的状态和生命周期，它会从 UI 的根节点一直往下传，连接所有调用到的 Composable 函数，所以 Composer 知道上一次渲染的状态，而且这些状态都有对应的位置。</p>
<p>Composer 的实现包含了一个与 Gap Buffer（间隙缓冲区）密切相关的数据结构 SlotTable，像是我们熟悉的 HashMap 一样，一个 key 对应到一个状态，这里的 key 就是上面反编译代码新增的第二个参数 $changed，它是这个函数的调用点所代表的源码位置的哈希值。</p>
<h4 id="间隙缓冲区是如何工作的">间隙缓冲区是如何工作的？</h4>
<p>这里我们简单理解一下间隙缓冲区的工作原理。间隙缓冲区代表了一个包含了当前索引的集合，在内存里用数组来实现，这个数组的大小会比它代表的数据集合要大一些，没有被使用的空间被称为 Gap（间隙）。</p>
<p>一个正在执行的 Composable UI 层级在这个数据结构中可能如下所示。在这个SlotTable 数据结构中存在 CompositionData 和 CompositionGroup 两种概念的数据，分别表示单个的 UI 控件或者是一组控件。<br>
<img src="https://git4pl.github.io/post-images/1620379978423.png" alt="" loading="lazy"></p>
<p>假设已经完成了层级结构的执行，在某个时候，我们需要更新 UI，这会重新组合一些 UI 元素，这叫做重组（Recomposition）。重组的时候将索引值重置回数组开头并再次进行遍历，遍历过程中查看数据，然后可能什么也不做，或者更新数据值。</p>
<figure data-type="image" tabindex="1"><img src="https://git4pl.github.io/post-images/1620380008478.pn" alt="" loading="lazy"></figure>
<p>如果要改变 UI 结构，并希望插入一些新的控件，这时会在 SlotTable 中进行一次插入操作，将间隙插入到需要的位置，可以理解为将操作位置后面的原有数据平移到间隙后面，这样就可以在新插入的间隙处添加新的数据。</p>
<figure data-type="image" tabindex="2"><img src="https://git4pl.github.io/post-images/1620380040341.png" alt="" loading="lazy"></figure>
<p>我们再通过下面这段 Compose 代码及其反编译代码理解 Compose 编译器为我们做的事，并理解 SlotTable 数据结构的工作机制和性能问题。</p>
<pre><code>@Composable
fun Counter() {
    var count by remember { mutableStateOf(0) }
    Button(onClick = { count += 1 }) {
        Text(text = &quot;Count: $count&quot;, modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp))
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://git4pl.github.io/post-images/1620380073540.png" alt="" loading="lazy"></figure>
<p>可以看到编译器在函数体中插入了一些额外的调用，并且这些调用是 Composer 对象的 startXXXGroup 和 endXXXGroup 方法的成对出现，在 Composer 接口中定义了 Replaceable、Movable、Restart 和 Default 这几种 Group，这些 group 适用于不同逻辑控制条件，每个 group 本身是树形结构，类似 HashMap 的 SlotTable 数据结构可以高效地操作和复用 slot。</p>
<p>在 SlotTable 的操作性能方面，除了需要移动间隙时，其他的操作包括 get、move、insert 和 delete 都是常数级的时间复杂度，只有当 UI 结构发生改变时需要移动间隙，移动间隙的时间复杂度是 O(n)。通常我们定义好的 UI 内容不会频繁地改变，只是提供给 UI 展示的数据和 UI 属性会发生变化，所以 SlotTable 的操作性能是可接受的。</p>
<h4 id="位置记忆化是什么">位置记忆化是什么？</h4>
<p>Compose 中的这种类缓存的数据结构可以在 UI 中任意实现控制流，编译器管理 UI，它是基于位置记忆化实现的。</p>
<p>什么是位置记忆化呢？前文已经介绍了 Composable 函数在编译后编译器给添加了一个 Composer 的参数，它包含了当前组件在树形结构中的位置以及将要访问哪些节点的上下文信息。编译器的目标是保留这样的数据模型，并且要复用 UI 在上一次执行过程中创建的节点，不用在每次执行时都要创建新的节点，也就是希望缓存每个节点。假设要缓存每个节点，那么每次执行函数时，就需要以相同的顺序查看缓存。从上面反编译的代码中可以看出，Composer 对象调用的 group 方法中第一个参数是一个数值，从 Composer 的源码注释可以知道那个数值是基于代码位置的一个 key，也就是表明所调用的函数在代码文件中的行信息，所以这个 key 在同一个代码文件中不会重复。在 Composer 中用一个带有 Gap Buffer 的数组来缓存代表函数位置的 key，每次执行同一个 Composable 函数时，它的数据模型可以被复用，只要 UI 结构不改变，就只需要更新数据就可以了。</p>
<h4 id="kotlin-语言特性对-compose-的支持">Kotlin 语言特性对 Compose 的支持</h4>
<p>Jetpack Compose 完全采用 Kotlin 实现，Kotlin 提供的一些语言特性使得编写高质量的 Compose 代码变得很容易，理解了 Kotlin 的这些语言特性也能很好地理解 Compose 代码背后的运行机制。</p>
<ul>
<li>
<p>默认参数<br>
Kotlin 函数参数可以指定默认值，调用方没有明确传递相应的值时，系统会使用默认值，这减少了对函数的重载。默认参数结合命名参数使代码读起来更清晰，参数具有自描述性，也更容易理解代码。</p>
</li>
<li>
<p>高阶函数和 Lambda 表达式<br>
Compose 中的函数大量应用 Kotlin 高阶函数，高阶函数与 Lambda 表达式自然配对，如果只需要该函数在一处调用，那么可以直接在函数被调用处用 Lambda 表达式。特别地，如果需要的高阶函数调用位置是函数的最后一个参数，可以使用尾随 Lambda，直接将表达式部分放到函数的圆括号后面，用大括号包起来。</p>
</li>
<li>
<p>范围和接收器<br>
有些方法和属性仅在某一范围内可用，限定的范围可让你在需要的地方提供相关功能，避免意外地在不当之处使用该功能。</p>
</li>
<li>
<p>委托属性<br>
Kotlin 支持属性委托，这些属性就像字段一样被调用，但是它们的值是通过对表达式求值动态确定的。</p>
</li>
<li>
<p>解构数据类<br>
对于数据类，可以使用解构声明来轻松地访问数据。</p>
</li>
</ul>
<p>其他被应用的特性包括单例对象、类型安全构建器和协程等。</p>
<h4 id="重组的实现原理">重组的实现原理</h4>
<p>当 Composable 函数的输入变更时再次调用该函数的过程就是重组，Composable 函数重组是如何触发的呢？还是以上面的 Counter 函数为例，编译器在函数末尾调用 endGroup 方法返回一个 ScopeUpdateScope 对象，当对象不为空的时候调用 updateScope 方法，将在需要时重新调用当前的 Composable 函数。</p>
<p>当 Compose 根据新输入重组时，它仅仅调用可能已经更改的函数或 Lambda，会跳过其余的函数或 Lambda，这样 Compose 可以高效地重组。</p>
<h3 id="关于-compose-的注意事项">关于 Compose 的注意事项</h3>
<p>在使用 Compose 编程时有许多注意事项，大概就像我们用 Android View 框架开发自定义 UI 组件时那样，不能在 onDraw 方法中执行耗时的任务，也不要在 onDraw 方法中创建对象等等，使用 Compose 编程的最佳做法是使 Composable 函数保持快速执行、幂等且没有副作用，因为 Compose 具有以下特点：</p>
<ul>
<li>
<p>Composable 函数可以按任何顺序执行<br>
在有 Composable 函数的代码中，Composable 函数可能不会按其在代码中出现的顺序执行，Compose 可以识别出某些 UI 元素的优先级高于其他 UI 元素，因而首先绘制这些元素。</p>
</li>
<li>
<p>Composable 函数可以并行执行<br>
Compose 可以通过并行运行 Composable 函数来优化重组，这样 Compose 就可以利用多个核心，并以较低的优先级运行 Composable 函数，Composable 函数可能会在后台线程池中执行。所以 Composable 函数都不应有副作用。</p>
</li>
<li>
<p>重组会跳过尽可能多的 Composable 函数和 Lambda<br>
如果界面上的某些部分没有变化，Compose 会尽力只重组需要更新的部分。</p>
</li>
<li>
<p>重组是乐观操作<br>
Compose 预计会在参数再次更改之前完成重组，如果某个参数在重组完成之前更改了，Compose 可能会取消重组，然后使用新参数重新开始。</p>
</li>
<li>
<p>Composable 函数可以非常频繁地运行<br>
有时可能会针对界面动画的每一帧运行一个 Composable 函数，如果该函数执行耗时操作，就会导致界面卡顿。</p>
</li>
</ul>
<h3 id="与android-view交互">与Android View交互</h3>
<p>Jetpack Compose 是一套全新的 UI 构建框架，但它也能配合现有的 View 框架构建 UI，官方建议构建新的应用最好选择 Compose 实现整个界面，当然需要等 Compose 正式发布后，对于现有的应用可以使用 Compose 和 View 结合逐步修改界面的构建方式。</p>
<p>Compose 与 Android View 的结合使用主要有两种方式：</p>
<ul>
<li>在Android View 中使用 Compose</li>
<li>在Compose 中使用 Android View</li>
</ul>
<p>如果要将 Compose 界面内容加入到现有的 View 布局中，可以使用 ComposeView 组件，调用其 setContent 方法，在该方法中可以直接调用 Composable 函数。ComposeView 是一个 Android View，可以像其他 View 组件一样放到 XML 布局中，然后用 id 获取 ComposeView，并调用 setContent() 以使用 Compose。如果整个 UI 布局是使用 Compose 构建的，可以直接在 fragment 中添加 ComposeView，这样可以完全避免使用 XML 布局文件。</p>
<p>另一方面，如果要在 Compose 构建的界面中添加 Android View 控件或层级结构，可以使用 AndroidView 可组合项。系统会向 AndroidView 传递一个返回 View 的 Lambda，同时提供了在布局加载完成后被调用的 update 回调，每当在该回调中读取的 State 发生变化时，AndroidView 都会进行重组。</p>
<h3 id="refers-to">Refers To</h3>
<p><a href="http://intelligiblebabble.com/compose-from-first-principles/">Compose From First Principles</a><br>
<a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd">Under the hood of Jetpack Compose</a><br>
<a href="https://slacker.ro/2021/03/08/%e5%88%9d%e6%8e%a2-jetpack-compose%e2%80%8a-%e2%80%8a%e6%b8%b2%e6%9f%93%e6%a9%9f%e5%88%b6%ef%bc%88rendering%ef%bc%89/">初探 Jetpack Compose — 渲染機制（Rendering）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初探Jetpack Compose]]></title>
        <id>https://git4pl.github.io/post/uDFS_pXuN/</id>
        <link href="https://git4pl.github.io/post/uDFS_pXuN/">
        </link>
        <updated>2021-04-11T02:37:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jetpack-compose是什么">Jetpack Compose是什么？</h2>
<p>Jetpack Compose是Google在2019年5月的I/O大会上公布的Android最新的UI框架，官网上介绍它可以简化并加快 Android 上的界面开发，使用更少的代码、强大的工具和直观的 Kotlin API，快速让应用生动而精彩。经过两年多的开发，Jetpack Compose目前是Beta版本。<br>
<img src="https://git4pl.github.io/post-images/1618108739331.png" alt="" loading="lazy"></p>
<p>从2008年谷歌正式发布Android系统后，一直到2019年推出Jetpack Compose，Android系统在长达10多年的发展过程中，谷歌针对不同的问题都做过了很多调整，但是在UI构建方面，除了陆续推出RecyclerView、CardView、ConstraintLayout等高级UI控件外，Android系统最初的那一套View System一直沿用到今天，UI构建体系几乎没有做任何改变，View.java 文件已经有超过30000行代码了。谷歌官方也清楚View系统越来越庞大，并且有一些问题，但很为难的是不能轻易修改现有的View类，因为有很多应用可能依赖了这些API。<br>
<img src="https://git4pl.github.io/post-images/1618108783701.png" alt="" loading="lazy"></p>
<p>Jetpack Compose直接抛弃了View和ViewGroup那一套东西，从渲染机制、布局机制、触摸算法到 UI 的具体写法都是全新的方式，它受到React、Litho、Vue.js 和 Flutter的启发，完全采用Kotlin开发，实现声明式UI。</p>
<h2 id="compose解决什么问题">Compose解决什么问题？</h2>
<p>我们知道软件工程中有个原则是高内聚低耦合，高内聚是指一个软件模块由相关性很强的代码组成，只负责一项任务，即遵循单一职责原则；低耦合指一个完整的系统中模块与模块之间尽可能相互独立，每个模块独立完成特定的子功能，模块间通信的接口尽可能少而简单。编写代码时我们会创建包含多个单元的模块，&quot;耦合&quot; 便是不同模块中单元之间的依赖关系，它反映了一个模块中的各部分是如何影响另一个模块的各个部分的；&quot;内聚&quot; 则表示的是一个模块中各个单元之间的关系，它指示了模块中各个单元相互组合的合理程度。<br>
<img src="https://git4pl.github.io/post-images/1618108797869.png" alt="" loading="lazy"></p>
<p>当我们用Android View框架实现app的UI时我们需要 view model + 布局 共同完成，view model提供数据给布局，布局文件渲染出UI效果。通常view model会使用像 Kotlin或Java 这样的编程语言实现，而布局则使用 XML，由于两种实现语言的差异，即使view model与xml布局联系紧密，它们之前也有明显的分隔线，它们的联系属于模块间的耦合关系。</p>
<p>实际上这里隐藏了很多依赖关系，我们通过使用一些API访问布局中的UI控件，比如findViewById(ResId)、button.setText(String)、container.addChild(View)、img.setImageBitmap(Bitmap)等，使用这些API需要了解xml布局如何定义并创建view model和布局的关联，由于xml布局文件通常没有很好的可复用性，随着app的规模逐渐增长，这些依赖关系将越积越多。</p>
<p>当我们处理紧耦合的模块时，对一个地方的代码改动，便意味对其他的模块作出许多其他的改动，手动地修改代码增加了犯错的可能性。更糟的是有些耦合常常是隐式的，以至于看起来毫无关联的修改，却会造成了意料之外的错误发生。大多数现代应用会动态展示 UI，并且会在执行过程中不断演变。结果导致应用不仅要验证布局 XML 是否静态地满足了这些依赖关系，而且还需要保证在应用的生命周期内满足这些依赖。如果一个元素在运行时离开了视图层级，一些依赖关系可能会被破坏，并导致NullPointerException等问题。<br>
<img src="https://git4pl.github.io/post-images/1618108938524.png" alt="" loading="lazy"></p>
<p>这就引出了一个问题: 如果我们用和实现view model相同的语言定义布局与UI结构会怎样？如果我们选用 Kotlin 来做这件事会怎样？</p>
<p>Jetpack Compose完全采用Kotlin语言开发，你可以运用底层语言的全部灵活特性。由于我们可以使用相同的实现语言，一些隐式的依赖关系可能会变得更加明显，我们也可以重构代码并将其移动至那些可以使它们减少耦合和增加内聚的位置。<br>
<img src="https://git4pl.github.io/post-images/1618108960929.png" alt="" loading="lazy"></p>
<p>你可能会以为这是建议将逻辑与 UI 混合起来，实际上无论如何组织架构，你的应用中都将出现与 UI 相关联的逻辑。Compose 框架本身并不会改变这一点，不过框架可以为你提供一些工具，从而帮你更简单地实现关注点分离: 这一工具便是 Composable 函数。它就像你已经很熟悉的普通函数一样，你在使用普通函数时所掌握的重构和编写可靠、可维护、干净代码的技能都可以运用到 Composable 函数上。</p>
<p>Android View 框架的耦合性还体现在 View 组件的继承实现方式上，前文已说明 View 类拥有将近3万行代码，而所有 UI 控件都继承自该类，导致一些本身功能很简单的控件通过继承获得了很多不需要的属性和行为，所以在软件设计原则中有组合优于继承的说法。Compose 框架使用一组接受数据并生成 UI 元素的 Composable 函数来构建 UI，后文将详细说明 Compose 的使用组合的优势。</p>
<h2 id="compose相比xml布局有啥优势">Compose相比XML布局有啥优势？</h2>
<p>Jetpack Compose库除了解决构建UI时的代码耦合问题，借助统一的Kotlin语言，用更少的代码、强大的工具和直观的API快速构建Android app，Compose相比XML布局还有什么优势呢？</p>
<h3 id="声明式ui-vs-命令式ui">声明式UI vs 命令式UI</h3>
<p>传统的 Android View 框架是面向对象的命令式UI工具，它通过加载xml布局文件，实例化一棵View控件树来初始化UI，每个控件都维护了自己的内部状态，并提供 getter/setter 方法，app逻辑层代码通过调用View控件暴露的方法来获取View的状态或者更新View状态。UI的更新依赖于逻辑层调用控件对象的 API，像是接受命令一样。</p>
<p>Jetpack Compose是声明式的UI框架，UI控件是相对无状态的，不对外提供 getter/setter 方法，实际上声明式UI控件不是对象，通过更新参数调用同一个 Composable 函数来更新 UI。在 Compose 框架中一切都是函数，并且都是顶层函数，Composable 函数响应快速，具有幂等性且没有副作用，幂等性是指使用同一参数多次调用此函数时它的行为方式相同。用一组函数来声明 UI，一个 Composable 函数可以嵌套另一个 Composable 函数，并且只能被 Composable 函数调用。</p>
<p>这里用一个例子说明命令式 UI 和声明式 UI 代码的区别。假设有一个带有未读消息图标的电子邮件应用。如果没有消息，应用会绘制一个空信封；如果有一些消息，我们会在信封中绘制一些纸张；而如果有 100 条消息，我们就把图标绘制成好像在着火的样子......<br>
<img src="https://git4pl.github.io/post-images/1618108980548.png" alt="" loading="lazy"></p>
<p>使用命令式实现，我们可能会写出下面这样更新消息数量的逻辑函数：</p>
<pre><code>fun updateCount(count: Int) {
  if (count &gt; 0 &amp;&amp; !hasBadge()) {
    addBadge()
  } else if (count == 0 &amp;&amp; hasBadge()) {
    removeBadge()
  }
  if (count &gt; 99 &amp;&amp; !hasFire()) {
    addFire()
    setBadgeText(&quot;99+&quot;)
  } else if (count &lt;= 99 &amp;&amp; hasFire()) {
    removeFire()
  }
  if (count &gt; 0 &amp;&amp; !hasPaper()) {
   addPaper()
  } else if (count == 0 &amp;&amp; hasPaper()) {
   removePaper()
  }
  if (count &lt;= 99) {
    setBadgeText(&quot;$count&quot;)
  }
}
</code></pre>
<p>如果用声明式来实现这一逻辑和UI则会像下面这样：</p>
<pre><code>@Composable
fun BadgedEnvelope(count: Int) {
  Envelope(fire=count &gt; 99, paper=count &gt; 0) {
    if (count &gt; 0) {
      Badge(text=&quot;$count&quot;)
    }
  }
}
</code></pre>
<p>这里我们定义集中状态：</p>
<ul>
<li>当数量大于99时，显示火焰；</li>
<li>当数量大于0时，显示纸张；</li>
<li>当数量大于0时，绘制数量气泡。</li>
</ul>
<p>这便是声明式 API 的含义。我们编写代码来按我们的想法描述 UI，而不是如何转换到对应的状态。这里的关键是，编写像这样的声明式代码时，您不需要关注您的 UI 在先前是什么状态，而只需要指定当前应当处于的状态。框架控制着如何从一个状态转到其他状态，所以我们不再需要考虑它。</p>
<h3 id="组合-vs-继承">组合 vs 继承</h3>
<p>Android View 系统中的 UI 都是用 View 和 ViewGroup 对象的层级结构进行构建的，View 对象用于绘制用户可见的具体 UI 元素，ViewGroup 则是不可见的容器，用于布局 View 对象的排列方式；所有的 UI 元素都直接或间接地继承自 View 类，比如 EditText 继承自 TextView，而 TextView 又继承于 View，ViewGroup 类也继承于 View，自定义的容器类继承于 ViewGroup。<br>
<img src="https://git4pl.github.io/post-images/1618109033249.png" alt="" loading="lazy"></p>
<p>Jetpack Compose 使用组合而不是继承的方式构建 UI 元素，由于 Composable 函数都是顶层函数，Text、Image、CustomComposables 和所有 UI 组件都是 Composable 函数，它们通过组合其他函数一起构建 UI，Compose 还提供了一系列现成可用的布局来帮助排列 UI 元素，类似 View 框架中的 ViewGroup 容器。<br>
<img src="https://git4pl.github.io/post-images/1618109011415.png" alt="" loading="lazy"></p>
<p>我们知道软件设计中有一条原则是“多用组合，少用继承”，在《阿里巴巴Java开发手册》中也推荐谨慎使用继承的方式进行扩展，优先使用组合的方式实现。继承层次过深、继承关系过于复杂时会影响到代码的可读性和可维护性。</p>
<h3 id="单向数据流">单向数据流</h3>
<p>Jetpack Compose 参考了其他现代 UI 框架比如 Flutter 和 React 的思想，采取单一向下数据流和单一向上事件流的方式构建或重组 UI。简单来说，就是由父组件向子组件传递数据，子组件通过数据构建 UI，当子组件发送交互事件时，通过Lambda 方法将行为的发生交与父组件处理，父组件处理后修改数据，再通过单一向下数据流的原则通知子组件变化。</p>
<p>这是一种单向数据流的设计模式，这种模式下状态从有状态可组合项向下传递，而事件从无状态可组合项向上流动。<br>
<img src="https://git4pl.github.io/post-images/1618109087054.png" alt="" loading="lazy"></p>
<p>Compose 中的状态提升是一种将状态移至可组合项的调用方以使可组合项无状态的模式。Jetpack Compose 中的常规状态提升模式是将状态变量替换为两个参数：</p>
<ul>
<li>value: T：要显示的当前值</li>
<li>onValueChange: (T) -&gt; Unit：请求更改值的事件，其中 T 是建议的新值。</li>
</ul>
<pre><code>@Composable
fun HelloScreen() {
    var name by rememberSaveable { mutableStateOf(&quot;&quot;) }
    HelloContent(name) { name = it }
}

@Composable
fun HelloContent(name: String, onNameChanged: (String) -&gt; Unit) {
    Column {
        Text(
            text = &quot;你好, $name！&quot;,
            modifier = Modifier.padding(bottom = 8.dp),
            style = MaterialTheme.typography.h5
        )
        OutlinedTextField(
            value = name,
            onValueChange = onNameChanged,
            label = { Text(&quot;Name&quot;) }
        )
    }
}
</code></pre>
<p>使用 Jetpack Compose 时遵循此模式可带来下面几项优势：</p>
<ul>
<li>可测试性：将状态与显示状态的界面分离开来，更容易单独测试这两者。</li>
<li>状态封装：因为状态只能在一个位置进行更新，并且可组合项的状态只有一个可信来源，所以不太可能由于状态不一致而产生错误。</li>
<li>界面一致性：通过使用可观察的状态容器，例如 LiveData 或 StateFlow，所有状态更新都会立即反映在界面中。</li>
</ul>
<h2 id="compose框架组成">Compose框架组成</h2>
<p>Jetpack Compose 库由 androidx 中6个 Maven 组构成，每个组都包含一套特定用途的功能。</p>
<h4 id="composeanimation">compose.animation</h4>
<p>在Jetpack Compose 应用中构建动画，丰富用户体验。</p>
<h4 id="composecompiler">compose.compiler</h4>
<p>借助 Kotlin 编译器插件，转换 @Composable 函数并启用优化功能。</p>
<h4 id="composefoundation">compose.foundation</h4>
<p>使用现成可用的构建块编写 Jetpack Compose 应用，还可扩展 foundation 以构建你自己的设计系统元素。</p>
<h4 id="composematerial">compose.material</h4>
<p>使用现成可用的 Material Design 组件构建 Jetpack Compose UI，这是更高层级的 Compose 入口点，旨在提供与 www.material.io 上描述的组件一致的组件。</p>
<h4 id="composeruntime">compose.runtime</h4>
<p>Compose 的编程模型和状态管理的基本构建模块，以及 Compose 编译器插件针对的核心运行时库。</p>
<h4 id="composeui">compose.ui</h4>
<p>与设备互动所需的 Compose UI 的基本组件，包括布局、绘图和输入。</p>
<h3 id="refers-to">Refers To：</h3>
<p><a href="https://juejin.cn/post/6885900954307133448">深入详解 Jetpack Compose | 优化 UI 构建</a><br>
<a href="https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f">使用Compose前后</a><br>
<a href="https://blog.csdn.net/zhireshini233/article/details/114708862">Jetpack Compose漫谈</a><br>
<a href="https://juejin.cn/post/6844903982742126600">Jetpack Compose 最新进展</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于背压的理解]]></title>
        <id>https://git4pl.github.io/post/imXjzp6FH/</id>
        <link href="https://git4pl.github.io/post/imXjzp6FH/">
        </link>
        <updated>2021-01-20T08:19:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="背压是什么">背压是什么？</h3>
<p>初次听到“背压”这个词感觉像是“天王盖地虎”这样的行话，不知道是什么，感觉很高深的样子。</p>
<p>网络上有很多关于背压的文章，但对背压这个词的解释各不相同。有的人把它看作一个需要避免的问题，或者程序的异常，描述语言类似于“...发生了背压”；有的人说背压是解决这种在异步场景中被观察者发送事件速度远快于观察者的处理速度的问题的策略；还有的人认为背压是具有解决这种问题的能力或机制，比如说某某库支持背压或不支持背压。</p>
<p>维基百科上对 Backpressure 的定义是：Backpressure is a resistance or force opposing the desired flow of fluid through pipes（背压是抵抗所需的流体通过管道流动的阻力或反作用力），借用到软件领域它的定义应该是：Backpressure is a resistance or force opposing the desired flow of data through software。</p>
<p>国内有位Android大咖<a href="https://www.zhihu.com/people/rengwuxian">扔物线</a>在知乎上的一篇关于背压的回答我比较赞同，他说 Backpressure 其实是一种现象：在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure 出现。响应式编程中的【背压（Backpressure）】概念来源于流体力学的比喻，也和其他工程领域的背压概念相似，比如在管道运输中，气流或液流由于管道突然变细、急弯等原因导致由某处出现了下游向上游的逆向压力，这种情况称为 Backpressure。背压是我们在软件开发中经常遇到并且有时不得不处理的问题，但这个词以及表达的现象并没有被正确地理解和认识。背压并不是一种机制，也不是一种策略，背压现象中关键是下游的 Buffer 溢出。</p>
<h3 id="背压的例子">背压的例子</h3>
<h4 id="读写文件">读写文件</h4>
<p>一般写文件比读文件要慢，假设一个磁盘驱动有效的读文件速度是150MB/s，而写文件速度是100MB/s，如果要以最快的速度将文件读入内存，同时又以最快的速度将其写回磁盘，则必须每秒缓冲50MB，这样内存将被不断被堆积，在输入文件被完全读取之前，内存中还有大量的数据没有被写入文件。假设要读入一个6GB的文件然后将它写入磁盘，在你读完全部文件时，还有2GB的内容等待写入。</p>
<pre><code>6 GB / 150 MB/s = 40 s
150 MB - 100 MB = 50 MB
50 MB x 40 = 2 GB !!!
</code></pre>
<p>这将浪费很多的内存，在一些系统上可能超出了可用内存，最终产生OutOfMemory Exception，这就是由于写文件速度慢于读文件速度产生了背压问题。</p>
<h4 id="服务器通信">服务器通信</h4>
<p>另一个关于背压问题的例子是服务器间的通信问题。在普遍采用的微服务架构中，各个服务器的职责一般是独立分散的，当一台服务器向另一台服务器发送请求的速度快于后者处理请求的速度时，通常会出现背压。<br>
如果服务器A向服务器B发送100个rps（每秒请求数），但服务器B只能处理75个rps，那么对于服务器B就有25个rps的富余。此时服务器B可能会落后，因为它需要处理这些请求，或者还需要与下游的其他服务器通信。这是由于服务器处理能力的差异，导致上下游通信的服务器在处理请求时产生了背压问题。</p>
<figure data-type="image" tabindex="1"><img src="https://git4pl.github.io/post-images/1611130854773.gif" alt="" loading="lazy"></figure>
<h4 id="渲染ui">渲染UI</h4>
<p>在渲染UI方面也经常发生背压的现象，当程序无法以所需的速度渲染时，就会发生背压，比如Android App的卡顿现象是由于应用程序的渲染速度没有达到60fps。</p>
<h3 id="如何解决背压">如何解决背压</h3>
<p>可以看出背压现象在我们的程序开发中普遍存在，而且各个场景下处理背压的思路都差不多。除了扩展可用的计算资源外，如何处理背压问题可以概括为三种可能的选择：</p>
<ul>
<li>控制生产者产生数据的速度以适应消费者的响应速度</li>
<li>缓存临时产生的大量数据</li>
<li>丢弃上游发出的事件（可能有多种策略）</li>
</ul>
<p><strong>控制</strong>生产者可能是处理背压问题的最优选择，如果这种方案可行的话，它只需要考虑设计好控制机制，而不会有内存和其他资源的开销。在数据消费端不需要额外的内存来缓存数据，也不需要顾虑丢弃数据。不幸的是控制生产者产生数据并不总是可行，比如数据的输入是用户操作，我们不能控制程序系统之外的数据生产者。</p>
<p><strong>缓存</strong>是大多数背压问题的解决方式。Backpressure 和 Buffer 是一对相生共存的概念，一方面只有设置了 Buffer，才有 Backpressure 出现；另一方面只要设置了 Buffer，一定存在出现 Backpressure 的风险。使用缓存时要考虑，缓冲区的增长速度有可能在相当长的一段时间内超过它的消耗速度吗？如果缓冲区是无界的，那么缓冲区可能是危险的，这意味着对缓冲区没有大小或时间限制。</p>
<p><strong>丢弃</strong>是最后一种策略，它也经常与缓存相结合。比如基于时间的采样，每秒丢弃10%的数据。丢弃的具体策略有多种。</p>
<h3 id="rxjava中如何解决背压">RxJava中如何解决背压？</h3>
<p>RxJava是一个使用可观察序列组成异步和基于事件的程序的库，在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或订阅者不能及时处理相关的消息，那么随之而来的问题就是如何处理这些不断累积的未处理的消息？</p>
<p>RxJava从1.x到3.x不同版本对这个问题的应对方式和支持力度不同，很多文章说RxJava 1.x不支持背压，根据这些文章的描述，我理解不支持背压说的是RxJava 1.x版本的Observable不能直接添加解决背压的策略，而RxJava 2.x以后版本的Flowable可以通过参数设置背压策略，其实RxJava 1.x版本提供了支持解决背压的其他操作符，比如onBackpressureBuffer、onBackpressureDrop和onBackpressureLatest。在使用Observable发射数据后不使用解决背压的操作符进行处理，或者在使用了背压策略后观察者仍不能及时处理上游的数据的情况下，可能会抛出MissingBackpressureException表示发生了背压问题。</p>
<p>Observable 数据流可分为两种类型：Cold 和 Hot Observable，并不是严格的概念区分，它们只是对于两类被观察的数据流的形象描述。</p>
<ul>
<li>Cold Observable：指的是被观察者发射数据的时机和频率由观察者决定，每个观察者都能接收到完整的事件序列，cold observable的示例包括数据库查询、文件检索和Web请求等</li>
<li>Hot Observable：指的是被观察者在被创建后就立即发射数据，观察者会在建立对被观察者的订阅关系时接收到数据，它不能干涉hot observable发射数据的行为，示例包括鼠标或键盘事件、系统事件等</li>
</ul>
<h4 id="recative-pull">Recative Pull</h4>
<p>用<em>控制</em> 的方式解决背压问题可以通过阻塞被观察者的线程来实现，这有个缺点就是违背了Rx的响应式和非阻塞的模式。如果被观察者生产数据和观察者接收数据都在同一个线程，这就天然地形成了通过阻塞方式来解决背压问题。RxJava 提供了一种响应式拉取（Reactive Pull）的方式实现异步线程阻塞以解决背压问题，通过实现Subscriber类来订阅Observable，在 subscriber 的 onStart()方法中调用Subscriber.request(n) 方法，其中n表示观察者在下次调用request方法前被观察者可发送的最大数据量。在subscriber 的 onNext()中处理完已发送的数据后，可以再次调用request()方法，以指示Observable再发射一些数据。</p>
<pre><code>someObservable.subscribe(new Subscriber&lt;T&gt;() {
    @Override
    public void onStart() {
      request(1);
    }

    @Override
    public void onCompleted() {
      // gracefully handle sequence-complete
    }

    @Override
    public void onError(Throwable e) {
      // gracefully handle error
    }

    @Override
    public void onNext(T n) {
      // do something with the emitted item &quot;n&quot;
      // request another item:
      request(1);
    }
});
</code></pre>
<h4 id="rxjava背压操作符">RxJava背压操作符</h4>
<p>Cold Observables非常适合采用响应式拉取方式解决背压，Cold Observable可能会被转化成Hot Observable，而Hot Observable不适合用响应式拉取的方式。RxJava 提供了一些流控策略的操作符解决背压，这些操作符的基本原理都是采用<em>缓存</em>或<em>丢弃</em>策略，来调节被观察者发射数据的频率。</p>
<h5 id="buffer">buffer</h5>
<p>buffer 操作符可以使观察者以固定的时间间隔周期性地接收到被观察者发送的数据，被观察者发射的数据不会被丢失。<br>
<img src="https://git4pl.github.io/post-images/1611130890101.png" alt="" loading="lazy"></p>
<h5 id="window">window</h5>
<p>window 与 buffer 类似，一个窗口类型可以让被观察者以固定的时间间隔发射可观察到的窗口，还可以选择在每次从可观察源收集特定数量的数据项时发出一个新窗口。<br>
<img src="https://git4pl.github.io/post-images/1611130927060.png" alt="" loading="lazy"></p>
<h5 id="samplethrottlelast">sample(throttleLast)</h5>
<p>sample 操作符可以从被观察者发射的数据序列中周期性地获取数据，并且取观察周期内最近发射的数据。<br>
<img src="https://git4pl.github.io/post-images/1611130939445.png" alt="" loading="lazy"></p>
<h5 id="throttlefirst">throttleFirst</h5>
<p>与 sample 类似周期地获取数据，但是取在一个观察周期后面发射的第一个数据。<br>
<img src="https://git4pl.github.io/post-images/1611130949480.png" alt="" loading="lazy"></p>
<h5 id="debounce">debounce</h5>
<p>debounce 操作符可以去除发射频率过快的数据，所以它获取的是被观察者发射的数据序列中没有后继者的那些数据。<br>
<img src="https://git4pl.github.io/post-images/1611130909637.png" alt="" loading="lazy"></p>
<h4 id="flowable">Flowable</h4>
<p>在RxJava 2.0 版本中加入了 Flowable，为了解决RxJava 1.x中 Observable 不直接支持背压的问题。Flowable 支持背压是通过在 create 方法中传入 BackpressureStrategy 指定解决背压的策略，并且提供了默认的缓存大小为128。BackpressureStrategy是一个枚举类型，具体策略的实现原理根据字面意思与上面对应的操作符类似。</p>
<pre><code>public enum BackpressureStrategy {
    //不指定背压策略
    MISSING,
    //出现背压就抛出异常
    ERROR,
    //指定无限大小的缓存池，此时不会出现异常，但无限制大量发送会发生OOM
    BUFFER,
    //如果缓存池满了就丢弃掉之后发出的事件
    DROP,
    //在DROP的基础上，强制将最后一条数据加入到缓存池中
    LATEST
}
</code></pre>
<h3 id="总结">总结</h3>
<p>解决背压的策略并不能消除过度生产或者消费不足的问题，它只是把问题转移到一个可以更好处理的操作链上。再次理解背压可以总结为：</p>
<ol>
<li>
<p>只要上游生产速度不会快到让系统崩溃或者应用场景不可接受，那么不用设置 Buffer，从而也就不用考虑 Backpressure发生。</p>
</li>
<li>
<p>只有上游生产速度可能会快到让系统崩溃，并且事件是可以丢弃的，才需要设置 Buffer。当 Buffer 有上限的时候，Backpressure 也就有可能出现；一旦 Backpressure 出现，只能选择丢弃，只是具体的丢弃策略可以根据需求而定（全部丢弃、只保留最新的一个而丢弃其余的等等，丢弃根本基本原则）。</p>
</li>
<li>
<p>如果上游生产速度可能会快到把系统搞崩溃，而事件也不可丢弃，这个时候可能修改程序的设计了：修改代码设计来规避风险，或者修改软件设计、通过让步的方式来从根源上避免问题发生。但这已经不是 Buffer 或者 Backpressure 能解决的问题了。</p>
</li>
</ol>
<h3 id="refers-to">Refers To</h3>
<p><a href="https://www.zhihu.com/question/49618581">如何形象的描述反应式编程中的背压(Backpressure)机制？</a><br>
<a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">Backpressure</a><br>
<a href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7">Backpressure explained — the resisted flow of data through software</a><br>
<a href="https://proandroiddev.com/rxjava-backpressure-and-why-you-should-care-369c5242c9e6">RxJava Backpressure and why should you care?</a><br>
<a href="https://juejin.cn/post/6844903473016733710">关于 RxJava 背压</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们一起走过2020]]></title>
        <id>https://git4pl.github.io/post/XT99my5Cu/</id>
        <link href="https://git4pl.github.io/post/XT99my5Cu/">
        </link>
        <updated>2021-01-19T11:28:59.000Z</updated>
        <content type="html"><![CDATA[<p>2020年终于过去了，这一年我们经历了很多事，有喜乐也有烦扰，从宏观环境到我们个人周遭都发生了很多事，在2020年的最后一天总结回顾一下这一年发生在我身边的大小故事吧。</p>
<h2 id="关于我个人">关于我个人</h2>
<p>关于我个人，在2020这一年里也是起起伏伏有喜有忧，对我个人而言最重要的就是家和事业。</p>
<p>1月份回到老家完成我的婚礼，完成婚礼就标志我正式有了自己的家，家里有了妻子有了儿子，他们是我最爱的人也是最爱我的人；10月份我回老家把老妈接到北京来住，她很开心，一直想跟我一起住，这一年是我和妈妈一起朝夕相处生活的时间最长的时候。有我老妈包括丈母娘来和我们小家一起住，我的这个家才圆满了，叫做一家老小其乐融融！</p>
<p>过完春节在全国疫情还不明朗的情况下，我独自从老家回到北京开始工作，2、3月份都是在家里远程办公，4月份疫情减轻了，回到公司办公。而这时我遭遇了职业生涯的第一次裁员，公司倒是按正规的补偿方案给予被裁员工补偿的，但是在全国乃至全世界疫情没有得到有效控制经济环境不好的情况下，丢掉工作是一件让人忧心的事，加之当时正值我孩子要出生的时候，的确给我不小的压力。遇到困难只有直面问题认真对待才不会被困难吓倒，我镇定下来在5月份一个月认真准备面试，积极寻找工作机会，终于在6月初入职了新的公司。</p>
<p>在经济大环境不好的条件下经历过裁员其实给了我不小的成长，懂得了一定要在职业上有圈子、有知识技能的沉淀，同时还要不断学习新技术。做技术的其实不用太担心工作机会缺少，只要练好基本功，再加上一些人脉资源和业务素养，在现代社会是有很多工作机会的；但对自己一定要有高标准，有对更好工作机会的追求热情，这就需要在某些领域技术有深度的积累。今年的特殊环境催生了大量对音视频领域的技术人才需求，而音视频也是经久不衰的技术领域，所以在第四季度我报了一个网络课程，全面深入地学习音视频开发的技术。原本计划今年考研究生，但在下半年由于工作时间比较紧，加上有音视频开发的学习课程，以及更明确地通过平时工作学习积累，导致考研准备不足，所以取消了今年的考研计划，后面再考虑考研的事情。</p>
<h2 id="关于我们家庭">关于我们家庭</h2>
<p>这一年我们成立了自己的小家庭，1月份在我哥的全力帮助下完成了我和老婆的婚礼，亲友们见证了我成家的盛典，这是很多亲人期盼的一天，遗憾的是父亲没有见证这一幕。</p>
<p>5月份的时候，老婆在北京顺利生产了我们的第一个孩子，儿子皓荣出生以及一直到现在的成长都很顺利，这也许是命运对我的福报吧，感激！儿子出生后，丈母娘来北京照顾他们母子俩3月，那时候正是我在家准备面试和刚入职新公司，感谢她的付出！</p>
<p>有了孩子的家庭才更有家的气氛，老婆在家带儿子，我在外上班，有了家的氛围，工作生活都有了劲头。9月初在我们原来租住的房子到期后，我们换了新的住处，独立租了一个两居室，房子离我工作的地方很近，开始两个月还可以每天骑着电瓶车回家吃午饭。10月初，我把我老妈从老家接到北京来住，父亲走了快10年了，她一直想在老家跟哥一家住。她很想跟我一起住住，因为我一直没有成家，在大城市生活不容易，所以一直不能满足她的愿望。现在我结婚成家了，老婆也很有孝心，老妈过来住三个月了，她很喜欢和我们住一起，有老有小的一家是很幸福的家庭！</p>
<h2 id="关于我的国家社会">关于我的国家社会</h2>
<p>2020年必定是被铭记的一年，从年初开始新冠肺炎疫情就给整个国家带来了前所未有的紧张感。一种不明来历的病毒传染很快，对人的生命造成极大的威胁，而在国际上西方国家又一直对我国存有政治和意识形态的偏见，借助这次病毒首先在我国境内大面积传播的问题，以美国为首的西方国家对我国进行无底线的挑衅和打击，在春节期间国内应对疫情的状态有相当多的困难。好在国家治理有方，有条不紊地进行了全面的抗疫，到了天气回暖后的4、5月份，国内疫情初步得到了控制，生产生活有序地逐步恢复展开，全社会逐渐恢复勃勃生机。不过疫情仍然没有被完全控制，由于国外政府管理不利加上国外人民对病毒的轻视，新冠肺炎在欧美国家相继持续爆发了，出现了他们在年初嘲笑和打击的中国面对疫情时的种种问题。7、8月分后，中国不同的地方也偶尔发生一些小规模的疫情爆发问题，不过在中国已经形成了防疫的成熟应对方案，疫情不会发生大范围的如年初那样的失控的状态。</p>
<p>这一年一直有疫情笼罩着全世界，就算在这个最需要人类共同携手解决人类问题的时刻，人类世界中也不能避免政治、经济和意识方面的斗争。美国政府一直对我国的科技企业穷追猛打，华为公司的新产品供货受阻，只好选择整体打包出售其手机产品业务。美国还不忘在中国的主权和内政问题上添油加醋扰乱是非，它们关闭中国的驻美使馆，在香港台湾问题上使乱子，当然日渐强大的中国在适当的时候给了它们正面的回击。</p>
<p>国家社会大事不是我们渺小的个人所能左右的，但我们身在其中，必须要对时事有所了解，对大势有所判断，这些可能间接甚至直接地影响到我们的工作和生活。</p>
<p>2020就此别过吧，2021充满希望，希望祖国山河锦绣、国泰民安，祝愿自己在已有的幸福生活上继续努力，获得更美好的生活！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记部落帖子分享微信小程序封面图片合成的一些坑]]></title>
        <id>https://git4pl.github.io/post/WmBbWgxWB/</id>
        <link href="https://git4pl.github.io/post/WmBbWgxWB/">
        </link>
        <updated>2020-08-22T01:07:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="项目背景">项目背景</h3>
<p>58部落帖子详情的分享功能里分享到微信小程序，原有的封面图是由Server端下发的图片，若帖子是纯文本内容则Server下发的是58部落的广告默认图，这样分享出去的微信小程序封面图形势比较简单。为了丰富小程序封面图的内容，激起收到分享的用户点击进入小程序查看帖子的兴趣，本次项目针对这个小程序封面图进行优化设计。</p>
<p>新版本的分享到小程序的封面图设计是这样的：用帖子的素材合成一副新的封面图，要求封面图的顶部展示用户头像、名称以及帖子的浏览量。根据帖子是否带有图片，合成的封面图有两种不同的样式：<br>
1、带图片的帖子，取帖子第一张图片，在用户信息下面展示图片内容<br>
2、纯文本的帖子，取帖子正文内容展示在用户信息下面，最多显示6行帖子内容<br>
<img src="https://git4pl.github.io/post-images/1598063903913.png" alt="cover with picture" loading="lazy"><br>
<img src="https://git4pl.github.io/post-images/1598063965619.png" alt="cover with text" loading="lazy"></p>
<h3 id="实现方案">实现方案</h3>
<p>由于封面图中的元素都是Server动态下发的，尤其是图片需要下载后才能处理。一开始想到用UI控件来创建这个布局，可以很方便地利用控件的属性实现UI效果的细节，但是要生成的封面图没有Activity或者其他ViewGroup容器来承载它的绘制，最后采用Canvas + Paint来动态绘制，并将生成的Bitmap保存为本地文件。在实现这个UI效果的过程中遇到了一些技术上的小坑，记录下来以备后续复用。</p>
<h4 id="绘制圆形头像">绘制圆形头像</h4>
<p>利用Canvas绘制圆形图是很容易的事，通常可以使用这三种API在Canvas上实现圆形图：BitmapShader、ClipPath和PorterDuffXfermode。</p>
<h5 id="bitmapshager-图片渲染方式">BitmapShager 图片渲染方式</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个BitmapShader对象 使用传递过来的原Bitmap对象bmp
    BitmapShader bitmapShader = new BitmapShader(bmp, Shader.TileMode.CLAMP，Shader.TileMode.CLAMP);
 
    //paint设置shader
    paint.setShader(bitmapShader);
 
    //canvas画一个圆 使用设置了shader的paint
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);
   
    return newBitmap;
}
</code></pre>
<h5 id="clippath-裁剪区域">ClipPath 裁剪区域</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个Path对象，path添加一个圆 圆心半径均是r / 2， Path.Direction.CW顺时针方向
    Path path = new Path();
    path.addCircle(r / 2, r / 2, r / 2, Path.Direction.CW);
    //canvas绘制裁剪区域
    canvas.clipPath(path);   
    //canvas将图画到留下的圆形区域上
    canvas.drawBitmap(bmp, 0, 0, paint);
 
    return newBitmap;
}
</code></pre>
<h5 id="porterduffxfermode-图片混合模式">PorterDuffXfermode 图片混合模式</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);

    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);

    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);

    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);

    //canvas画一个圆形
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);

    //然后 paint要设置Xfermode 模式为SRC_IN 显示上层图像（后绘制的一个）的相交部分
    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));

    //canvas调用drawBitmap直接将bmp对象画在画布上 
    //因为paint设置了Xfermode，所以最终只会显示这个bmp的一部分 
    //也就是bmp的和下层圆形相交的一部分圆形的内容
    canvas.drawBitmap(bmp, 0, 0, paint);

    return newBitmap;
}
</code></pre>
<p>虽然上面三种方式都能绘出圆形图，但在实际项目需求中有一些坑需要注意。<br>
使用BitmapShader要注意图像缩放的处理，可以计算好缩放比例，使用Matrix对象设置缩放比例，然后将Matrix对象设置到BitmapShader对象中。<br>
使用Canvas的clipPath方法设置path，然后调用drawBitmap绘制的图形有锯齿现象，即使在paint中设置了抗锯齿参数也不能消除。<br>
使用Xfermode的方式，在实际项目中如果直接用上面代码里的写法将不能得到预期的圆形图，需要使用saveLayer方法将绘制操作保存到新的图层，将图像合成的处理放到离屏缓存中进行。</p>
<h4 id="文字居中绘制">文字居中绘制</h4>
<p>项目需求中要求顶部的用户头像和用户名水平方向居中对齐，这两者要居中对齐可以确定一个基准参考线，比如都关于顶部栏纵向的中线上下对称，头像关于该中线对称很容易实现，而要实现文字关于该中线的对称需要理解Android绘制文字的原理以及drawText方法的参数意义。<br>
<img src="https://git4pl.github.io/post-images/1598087533894.png" alt="" loading="lazy"><br>
Android的文字绘制是按如上图所示的基线绘制的，与之对应的实现是Paint类中的FontMetrics类的定义。</p>
<pre><code>public static class FontMetrics {
    /**
        * The maximum distance above the baseline for the tallest glyph in
        * the font at a given text size.
        */
    public float   top;
    /**
        * The recommended distance above the baseline for singled spaced text.
        */
    public float   ascent;
    /**
        * The recommended distance below the baseline for singled spaced text.
        */
    public float   descent;
    /**
        * The maximum distance below the baseline for the lowest glyph in
        * the font at a given text size.
        */
    public float   bottom;
    /**
        * The recommended additional space to add between lines of text.
        */
    public float   leading;
}
</code></pre>
<p>drawText()方法的x、y指定要绘制文字的基准点，该基准点是要绘制的文字基准线上的left、center、right三点之一（如下图），具体是哪个由paint的setTextAlign()方法设置，默认是left。<br>
<img src="https://git4pl.github.io/post-images/1598088667357.png" alt="" loading="lazy"><br>
要让所画的文字刚好相对于我们选定的参考线上下居中，即让文字的中心点落在参考线上，我们需要计算调用drawText()方法的y坐标，即上图中基线的y坐标值。可以将问题转化为计算中心点相对于基线的距离，文字中心点相对于其基线的距离可表示为 (top+bottom)/2 - bottom，在屏幕坐标系中top的实际值相对于基线是负数，所以前述距离公式为 (-top+bottom)/2 - bottom，简化后为 -top/2 - bottom/2，将此值加上参考线的y坐标值即为我们所求的y坐标。另外要注意paint.getFontMetrics()这个方法一定要在设置字体大小或者样式等一系列会影响字体的方法后调用，不然获取到的top和bottom值不准。</p>
<pre><code>Paint paint = new Paint();
paint.setTextSize(textSize);
paint.setAntiAlias(true);
Paint.FontMetrics fm = paint.getFontMetrics();
float top = fm.top;
float bottom = fm.bottom;
float baseLineY = (headH &gt;&gt; 1) - top / 2 - bottom / 2;
canvas.drawText(username, x, baseLineY, paint);
</code></pre>
<h4 id="绘制多行文字">绘制多行文字</h4>
<p>Canvas.drawText()只能绘制单行的文字，不能换行。它既不能在View的边缘自动折行显示，也不能在换行符\n处换行。而StaticLayout 支持换行，它既可以为文字设置宽度上限来让文字自动换行，也会在 \n 处主动换行。<br>
StaticLayout通过构造函数参数设置文字显示的属性。StaticLayout 的构造方法是 StaticLayout(CharSequence source, TextPaint paint, int width, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad)，其中参数里：</p>
<pre><code>width 是文字区域的宽度，文字到达这个宽度后就会自动换行；
align 是文字的对齐方向；
spacingmult 是行间距的倍数，通常情况下填 1 就好；
spacingadd 是行间距的额外增加值，通常情况下填 0 就好；
includepad 是指是否在文字上下添加额外的空间，来避免某些过高的字符的绘制出现越界。
</code></pre>
<h4 id="图片裁剪压缩">图片裁剪压缩</h4>
<p>微信分享SDK对分享到微信小程序的封面图大小有限制，要求体积不超过128KB，对图片分辨率没有明确要求，但是在不同机型以及平台终端上展示分享出去的小程序链接里发现微信SDK对封面图的尺寸比例是有要求的。小程序在显示分享的封面图时，图片的宽高比为5:4，不符合这个比例的尺寸，微信客户端将会对其进行裁剪。</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="https://blog.csdn.net/zly921112/article/details/50401976">android canvas drawText()文字居中</a><br>
<a href="https://www.jianshu.com/p/5136fbc0d301">StaticLayout支持文字绘制换行</a><br>
<a href="https://blog.csdn.net/TO_BE_RM/article/details/79859540">初识Android Bitmap压缩原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Canvas绘制圆形图]]></title>
        <id>https://git4pl.github.io/post/Vgyf9i2nb/</id>
        <link href="https://git4pl.github.io/post/Vgyf9i2nb/">
        </link>
        <updated>2020-08-16T10:35:52.000Z</updated>
        <content type="html"><![CDATA[<p>最近实现一个业务需求，要求将用户头像、用户名和正文内容合成为一张图片，以作为给微信小程序分享的封面图。通过一些ImageView控件是很容易实现圆形头像的，但这里需要创建一块画布，在Canvas上画出圆形头像，如果细节处理不好，可能达不到理想的效果。<br>
通常用Java代码绘制圆形图有三种方法，分别是使用BitmapShader、PorterDuffXfermode和ClipPath。这里记录一下这三种画圆形图的代码实现：</p>
<h4 id="bitmapshager-图片渲染方式">BitmapShager 图片渲染方式</h4>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个BitmapShader对象 使用传递过来的原Bitmap对象bmp
    BitmapShader bitmapShader = new BitmapShader(bmp, Shader.TileMode.CLAMP，Shader.TileMode.CLAMP);
 
    //paint设置shader
    paint.setShader(bitmapShader);
 
    //canvas画一个圆 使用设置了shader的paint
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);
   
    return newBitmap;
}
</code></pre>
<h4 id="porterduffxfermode-图片混合模式">PorterDuffXfermode 图片混合模式</h4>
<pre><code>    public Bitmap getCirleBitmap(Bitmap bmp) {
        //获取bmp的宽高 小的一个做为圆的直径r
        int w = bmp.getWidth();
        int h = bmp.getHeight();
        int r = Math.min(w, h);
 
        //创建一个paint
        Paint paint = new Paint();
        paint.setAntiAlias(true);
 
        //新创建一个Bitmap对象newBitmap 宽高都是r
        Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
        //创建一个使用newBitmap的Canvas对象
        Canvas canvas = new Canvas(newBitmap);
 
        //canvas画一个圆形
        canvas.drawCircle(r / 2, r / 2, r / 2, paint);
 
        //然后 paint要设置Xfermode 模式为SRC_IN 显示上层图像（后绘制的一个）的相交部分
        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
 
        //canvas调用drawBitmap直接将bmp对象画在画布上 
        //因为paint设置了Xfermode，所以最终只会显示这个bmp的一部分 
        //也就是bmp的和下层圆形相交的一部分圆形的内容
        canvas.drawBitmap(bmp, 0, 0, paint);
 
        return newBitmap;
    }
</code></pre>
<h4 id="clippath-裁剪区域">ClipPath 裁剪区域</h4>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个Path对象，path添加一个圆 圆心半径均是r / 2， Path.Direction.CW顺时针方向
    Path path = new Path();
    path.addCircle(r / 2, r / 2, r / 2, Path.Direction.CW);
    //canvas绘制裁剪区域
    canvas.clipPath(path);   
    //canvas将图画到留下的圆形区域上
    canvas.drawBitmap(bmp, 0, 0, paint);
 
    return newBitmap;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于类加载的时机与过程]]></title>
        <id>https://git4pl.github.io/post/OH92heMH4/</id>
        <link href="https://git4pl.github.io/post/OH92heMH4/">
        </link>
        <updated>2020-07-19T02:54:31.000Z</updated>
        <content type="html"><![CDATA[<p>思考以下代码的输出结果：</p>
<pre><code>public class Singleton {
    private static Singleton instance = new Singleton();
    public static int count1;
    public static int count2 = 0;
    private Singleton() {
        count1 ++;
        count2 ++;
    }

    public static Singleton getInstance() {
        return instance;
    }
｝

public class Test {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println(&quot;count1 = &quot; + Singleton.count1);
        System.out.println(&quot;count2 = &quot; + Singleton.count2);
    }
}
</code></pre>
<blockquote>
<p>错误答案<br>
count1 = 1<br>
count2 = 1</p>
</blockquote>
<blockquote>
<p>正确答案<br>
count1 = 1<br>
count2 = 0</p>
</blockquote>
<p>这个问题就是牵涉到类的加载与过程，虚拟机定义了以下六种情况，如果类未被初始化，则会进行初始化：<br>
1、创建类的实例<br>
2、访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。<br>
3、访问类的静态方法<br>
4、反射如(Class.forName(&quot;my.xyz.Test&quot;))<br>
5、当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化<br>
6、虚拟机启动时，定义了main()方法的那个类先初始化</p>
<p>我们来分析以下上述代码的执行情况：</p>
<ol>
<li>main()方法 Test类初始化</li>
<li>main()方法第一句：访问Singleton的getInstance()静态方法 Singleton类初始化，此时按照代码执行顺序进行静态成员的初始化默认值<br>
instance = null<br>
count1 = 0<br>
count2 = 0</li>
<li>按照代码执行顺序为类的静态成员赋值：<br>
private static Singleton instance = new Singleton(); instance调用Singleton的构造方法,调用构造方法后 count1 = 1,count2 = 1<br>
public static int count1; count1没有进行赋值操作，所以count1 = 1<br>
public static int count2 = 0; count2进行赋值操作，所以count2 = 0</li>
<li>main()方法第二句：访问Singleton的count1变量，由于count1没有赋初始值，所以count1 = 1</li>
<li>main()方法第三句：访问Singleton的count2变量，由于count2赋了初始值 0，所以count2 = 0</li>
</ol>
<p>如果我们把Singleton代码执行顺序变化一下：</p>
<pre><code>public class Singleton {
    public static int count1;
    public static int count2 = 0;
    private static Singleton instance = new Singleton();

    private Singleton() {
        count1++;
        count2++;
    }

    public static Singleton getInstance() {
        return instance;
    }

}
</code></pre>
<p>此时输出结果就为:</p>
<blockquote>
<p>count1 = 1<br>
count2 = 1</p>
</blockquote>
<p>如果改为如下代码，那么运行情况又是怎样：</p>
<pre><code>public class Singleton {
    Singleton(){
        System.out.println(&quot;Singleton construct&quot;);
    }

    static {
        System.out.println(&quot;Singleton static block&quot;);
    }

    public static final int COUNT = 1;

}

public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;count = &quot; + Singleton.COUNT);
    }
}
</code></pre>
<p>运行结果为：</p>
<blockquote>
<p>count = 1</p>
</blockquote>
<p>由于常量在编译阶段会存入相应类的常量池当中，所以在实际调用中Singleton.COUNT并没有直接引用到Singleton类，因此不会进行Singleton类的初始化，所以输出结果为 count = 1</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="https://www.jianshu.com/p/27eb533b29f7">Kotlin:由object和companion object创建的单例模式引发的思考</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式笔记]]></title>
        <id>https://git4pl.github.io/post/NUANIynJT/</id>
        <link href="https://git4pl.github.io/post/NUANIynJT/">
        </link>
        <updated>2020-07-11T01:28:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="开篇小引">开篇小引</h3>
<p>在上大学时我做了一个小项目是关于人机交互的应用，我负责实现的部分是通过语音识别技术接收用户的问题，然后在数据库中检索预置的问题答案，并由我们的应用“说”出来对用户的问题进行解答。当时我就由这个应用的交互模式产生了一个小小的想法，我希望有一天可以实现一个很简单方便的东西能让中国的老奶奶和美国甚至更多其他国家的老奶奶坐在一起轻松愉快地聊天，完全不用担心各自语言的障碍，这涉及到语音识别和机器翻译等诸多技术，现在顶级的科技公司已经在各种细分的技术上有研究实践了。我的那个小想法其实与本篇博客的主题——适配器模式——有相似的实现思想。</p>
<h3 id="定义及特点">定义及特点</h3>
<p><strong>适配器模式将一个类的接口转换成客户期望的另一个接口，使得原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</strong></p>
<p>适配器模式可以通过创建适配器进行接口转换，让不兼容的接口变得能兼容。这可以让客户从实现的接口解耦，如果在一段时间之后，我们想要改变接口，适配器可以将改变的部分封装起来，客户端就不必为了应对不同的接口而每次跟着修改。</p>
<p>适配器模式涉及到三种角色：<br>
●  目标接口（Target）——定义客户期望的与特定领域相关的接口<br>
●  适配者类（Adaptee）——定义一个已经存在的接口，是需要适配的类<br>
●  适配器类（Adapter）——通过包装一个需要适配的对象，把原接口转换成目标接口</p>
<h3 id="适用场景">适用场景</h3>
<p>以下情况可使用适配器模式：<br>
√  系统需要使用现有的类，而这些类的接口不符合系统的接口<br>
√  想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作<br>
√  两个类所做的事情相同或相似，但是具有不同接口的时候<br>
√  旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候<br>
√  使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能</p>
<h3 id="实现方式">实现方式</h3>
<p>在GoF的设计模式中，适配器模式有两种可行的实现方式：<strong>类适配器</strong>和<strong>对象适配器</strong>，类适配器使用多重继承对一个接口与另一个接口进行匹配，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431276853.png" alt="" loading="lazy"><br>
对象适配器依赖于对象组合，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431299777.webp" alt="" loading="lazy"><br>
类适配器因为需要Adapter类同时继承自Target类和Adaptee类，所以只能在支持多重继承的语言中实现（Java虽然不支持多继承，但可以通过实现接口implements interface来实现类适配器，如下代码示例）；对象适配器模式充满着良好的OO设计原则：使用对象组合，以修改的接口包装被适配者，这样被适配者的任何子类，都可以搭配着适配器使用。</p>
<pre><code>public interface Target {
    /**
     * 这是适配者类Adaptee也有的方法
     */
    public void sampleOperation1(); 
    /**
     * 这是适配者类Adapteee没有的方法
     */
    public void sampleOperation2(); 
}

public class Adaptee {
    void sampleOperation1(){}
}

public class Adapter extends Adaptee implements Target {
    /**
     * 由于适配者类Adaptee没有方法sampleOperation2()
     * 因此适配器类Adapter补充上这个方法
     */
    @Override
    public void sampleOperation2() {
        //实现相关的代码
    }
}
</code></pre>
<p>类适配器和对象适配器有不同的权衡。<br>
类适配器：<br>
●  用一个具体的Adapter类对Adaptee和Target进行匹配，这使得Adapter不能和Adaptee的子类一起工作<br>
●  使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的子类<br>
●  仅仅引入了一个对象，并不需要额外的指针以间接得到Adaptee<br>
对象适配器：<br>
●  允许一个Adapter与多个Adaptee（即Adaptee本身以及它的所有子类）同时工作，Adapter也可以一次给所有的Adaptee添加功能<br>
●  重定义Adaptee的行为比较困难（这需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身）</p>
<h3 id="适配器小结">适配器小结</h3>
<p>使用适配器的优点：<br>
1、通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。<br>
2、复用了现存的类，解决了现存类和复用环境要求不一致的问题。<br>
3、将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。<br>
4、一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>
<p>使用适配器的缺点：<br>
过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/09/2582485.html">设计模式学习笔记-适配器模式</a><br>
<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">《JAVA与模式》之适配器模式</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[真的理解单例模式吗？]]></title>
        <id>https://git4pl.github.io/post/TjHrGm886/</id>
        <link href="https://git4pl.github.io/post/TjHrGm886/">
        </link>
        <updated>2020-07-07T12:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>单例模式是设计模式中最常用也最简单的一种模式，相信很多程序员小伙伴在求职面试过程中都被面试官问到过单例模式。虽然它的定义和类结构非常简单，但是要实现一个完全没有问题的单例模式却没有那么简单；即使能写出一个合格有效的单例模式，要把其中的逻辑原理讲述清楚令面试官满意也不容易。</p>
<p>单例模式的实现方式有很多种，不同的实现方式能适应不同的应用场景。单线程中的单例比较简单，单例模式的复杂性主要是在多线程并发环境下要充分考虑对象访问的性能、线程安全等问题。如何实现高性能、线程安全、防攻击的单例模式？对于线程安全的单例实现方式，它们分别是怎样保证线程安全的？DCL的单例实现中synchronized和volatile关键字分别有什么作用？带着这些问题我再深入学习一下单例模式。</p>
<h3 id="定义及特点">定义及特点</h3>
<p>单例模式确保一个类只有一个实例，并提供一个全局访问方法。其类结构图如下：<br>
<img src="https://git4pl.github.io/post-images/1594123603857.jpeg" alt="" loading="lazy"></p>
<p>单例模式是对象创建型模式，要实现一个单例类需满足以下几个要素：<br>
（1） 一个私有的构造方法<br>
（2） 一个指向自己实例的私有的静态引用<br>
（3） 一个返回自己实例的公有的静态方法<br>
所以一个单例类应该类似下面的伪代码：</p>
<pre><code>public class Singleton {
    private Singleton() {} //私有的构造方法
    private static Singleton singleton; //指向自己实例的私有静态引用
    public static Singleton getInstance() { //返回自己实例的公有静态方法
        …… //创建本单例类的唯一实例，并赋值给私有静态引用
        return singleton;
    }
}
</code></pre>
<p>其实，按照定义的方式写出的单例模式并不能保证单例对象的唯一，可以通过以下方法破坏一个单例类的实例唯一性：</p>
<ul>
<li>使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。</li>
<li>如果单例的类实现了cloneable，那么还是可以拷贝出多个实例的。</li>
<li>Java中的对象序列化也有可能导致创建多个实例。</li>
<li>使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。</li>
</ul>
<p>所以，如果要考虑单例类的防攻击，在实现时还需要做到防止反序列化、防止反射、防止克隆。</p>
<pre><code>//readResolve method to preserve Singleton property
private Object readResolve() throws ObjectStreamException {
    return INSTANCE;
}

//防止反射调用后创建新的Singleton实例
private static boolean flag = false;  
private Singleton() {
    synchronized(Singleton.class) {
        if (!flag) {
            flag = true;  
        } else {  
            throw new RuntimeException(&quot;单例模式被侵犯！&quot;);  
        }  
    }  
}

//防止克隆产生新的实例
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException(&quot;Cannot clone instance of this class&quot;);
}
</code></pre>
<p>因为单例类对象的生命周期是从实例被创建到应用程序结束，所以一个高质量的单例类还需要满足以下特点：<br>
√ 懒加载    ——  在需要时才创建单例类的实例<br>
√ 线程安全 —— 应保证在多线程环境下访问单例类不会创建多个实例<br>
√ 高性能    —— 获取单例对象的过程中应减少同步的消耗</p>
<h3 id="适用场景">适用场景</h3>
<p>由于单例类保证一个类只有一个实例，并且由此表现出了一些其他优点，使得单例模式是在开发中比较常用的一种设计模式。根据单例类的优点，单例模式通常适用于以下场景的类创建：<br>
● 需要频繁实例化然后销毁的对象<br>
● 创建对象时耗时过多或者耗资源过多，但又经常用到的对象<br>
● 有状态的工具类对象<br>
● 频繁访问数据库或文件的对象<br>
● 需要保证数据一致性的配置文件类或工具类对象</p>
<h3 id="实现方式">实现方式</h3>
<p>根据单例模式的思想以及单例类能解决的问题，单例模式的实现方式有多种，不同的实现方式可能在单例对象的实例化时机、线程安全性和访问性能方面有所不同。下面分别整理各种实现方式及其优缺点。</p>
<h4 id="饿汉式单例">饿汉式单例</h4>
<pre><code>public class Singleton {  
    private static Singleton instance=new Singleton();  
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;  
    }
} 
</code></pre>
<p>这种单例实现方法之所以被称为饿汉式是因为它利用JVM机制在单例类被加载时实例化。其实例化时机比较早，所以没有实现懒加载（Lazy Loading），即使这个实例在应用的生命周期内没有被使用到，也会因为已经被加载而占用一定的内存空间；另外这种实现方式也无法给单例的实例化过程传入必须的参数。饿汉式的实现方式比较简单，在单例类被加载到内存时就完成了实例化，避免了线程同步的问题；另外因为实例没有被使用而造成的内存浪费问题可以忽略，饿汉式单例的实现方式是被推荐使用的。<br>
饿汉式单例的实例化过程还有一种写法，不过本质上也是利用JVM的类加载机制，只是语法的应用而已，如下：</p>
<pre><code>private static Singleton instance = null;  
static {  
   instance = new Singleton();  
}
</code></pre>
<h4 id="懒汉式单例">懒汉式单例</h4>
<p>懒汉式单例的实现目的就是为了达到单例类的懒加载，即在单例类第一次被使用到的时候实例化该单例类，对应到单例类实现的基本要素就是在返回单例类实例的公有静态方法中去实例化单例对象。懒汉式单例的最直接最简单的实现如下：</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
<p>上述实现方式在实际项目中并不可取，因为它存在线程安全问题，当有多个线程去调用getInstance()方法获取Singleton的实例时，有可能得到的不是同一个对象，即有可能每个线程访问getInstance()方法时各自创建一个Singleton实例。要解决这种实现方式的线程安全问题，可以考虑加锁进行同步。</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {};
    public static synchronized Singleton getInstance() {
        if (instance == null) {
	    instance = new Singleton();
	}
	
        return instance;
    }
}
</code></pre>
<p>上面的改进是在getInstance()方法上加锁进行同步，这样虽然解决了线程安全的问题，但又带来了访问效率低下的问题。每个线程在访问getInstance()方法获得类实例的时候，都要进行同步操作，而其实这个方法只需执行一次实例化代码就够了，只要单例对象还存在就可以直接return给访问者。对懒汉式单例进一步优化得到了既能保证线程安全又能有较高的访问效率的<strong>双重检查锁(Double Checked Locking)实现</strong>。</p>
<h4 id="双重检测的单例">双重检测的单例</h4>
<pre><code>public class Singleton {
    private static volatile Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance(){
         if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
    }
}
</code></pre>
<p>双重检查锁的实现方式是比较健壮的懒汉式单例实现，有两个问题需要理解：<br>
1、双重检查有什么意义<br>
双重检查就是在getInstance()方法中有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检查一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检查的话就会生成多个实例了。<br>
假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p>
<p>2、静态引用instance前的volatile关键字有何作用<br>
主要在于instance = new Singleton();这句并非是一个原子操作，在JVM中这句话大概做了下面 3 件事情：<br>
① 分配一块内存空间M<br>
② 调用 Singleton 的构造函数在内存M上创建对象<br>
③ 将M的地址赋值给 instance 变量（执行完这步 instance 就为非 null 了）<br>
但是在JVM的即时编译器中存在指令重排序的优化，也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 ①-②-③ 也可能是 ①-③-②。如果是后者，则在 ③ 执行完毕、② 未执行之前，线程二执行到同步快外的检查，这时 instance 已经是非 null 了，所以线程二会直接返回 instance，但却没有完成初始化。<br>
<img src="https://git4pl.github.io/post-images/1603974948705.png" alt="" loading="lazy"></p>
<p>volatile 修饰符具有禁止指令重排序优化的特性，也就是说在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 ①-②-③ 或者 ①-③-② 之后，不存在执行到 ①-③ 然后取到值的情况。从「先行发生原则（happens-before）」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<h4 id="静态内部类实现单例">静态内部类实现单例</h4>
<pre><code>public class Singleton{
    private Singleton() {}
    private static class SingletonHolder{
        private static Singleton instance=new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
</code></pre>
<p>通过在类中创建一个静态内部类来实现单例模式也是利用了JVM的类加载机制保证只创建一份实例，同时与饿汉式单例一样具有线程安全性，而且客户在获取这个单例类实例的时候不会进行同步，没有性能缺陷，也不依赖 JDK 版本。静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时调getInstance()方法，才会装载SingletonHolder类实例化Singleton，这样就实现了单例类的懒加载。<br>
由于使用静态内部类实现单例避免了线程不安全的问题，并且有较高的访问效率以及实现了延迟加载，这种方式是值得推荐的单例实现方式，当然这种方式与饿汉式单例一样不能传入参数。</p>
<h4 id="枚举实现单例">枚举实现单例</h4>
<pre><code>public enum Singleton {
    INSTANCE;
    private Singleton() {}
    public void method() {
    }
 }
</code></pre>
<p>从Java1.5版本起，创建单例可以使用简洁的枚举类型，我们直接通过Singleton.INSTANCE来访问实例。对于枚举类型，编译器会自动帮我们创建一个final类型的类继承自Enum类，并且该类中的几个属性被定义成static final，在static代码块中初始化那些属性，枚举类型通过Java类加载机制和初始化过程保证线程安全；而且通过jvm规范保证序列化，枚举还能防止反序列化或者反射攻击导致创建新的实例。《Effective Java》中更是说明单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<h3 id="kotlin单例实现">Kotlin单例实现</h3>
<p>用Kotlin语言实现单例模式很简单，使用object关键字代替class关键字定义的类就是一个单例类。</p>
<pre><code>object Singleton {
    fun sayHello() {
        Log.d(&quot;TAG&quot;, &quot;Hello Kotlin&quot;)
    }

    init {
        Log.d(&quot;TAG&quot;, &quot;initialize the Kotlin class&quot;)
    }
}
</code></pre>
<p>将Kotlin实现的单例类的字节码转成Java代码，如下图：<br>
<img src="https://wos.58cdn.com.cn/IjGfEdCbIlr/ishare/e38f8dd9-af69-42be-ad30-1fa51ee77ef2kotlin_singleton.png" alt="kotlin_singleton.png" loading="lazy"></p>
<p>可见，上面的Kotlin单例类对应的Java代码其实是Java版本的饿汉式单例。单例对象在静态代码块中创建，单例类的静态引用被定义成public static final，因为在Java代码中访问这个单例对象时会调用它。如下分别是Kotlin和Java代码访问这个单例的方法：</p>
<pre><code>//Kotlin 调用
Singleton.sayHello()

//Java 调用
Singleton.INSTANCE.sayHello();
</code></pre>
<p>用object关键字声明的单例类无法给单例的实例化过程传入参数，可借助Kotlin的伴生对象companion object来实现带参数的单例，因为伴生对象中的方法和属性被绑定到类上，通过类名直接访问，它将在类被加载的时候初始化。</p>
<p>如下用伴生对象带参数实现双重检测的单例类：</p>
<pre><code>class Singleton private constructor(context: Context) {
    companion object {
        @Volatile
        private var instance: Singleton? = null
        fun getInstance(context: Context): Singleton {
            if (instance != null) {
                return instance as Singleton
            }

            return synchronized(this) {
                if (instance != null) {
                    instance as Singleton
                } else {
                    val created = Singleton(context)
                    instance = created
                    created
                }
            }
        }
    }
}
</code></pre>
<p>利用companion object还可以实现其他类型的单例模式的Kotlin版本。</p>
<h3 id="单例模式小结">单例模式小结</h3>
<p>单例模式是类结构和模式思想最简单的一种设计模式，也是实际项目在被使用最多的一种模式，Android SDK的许多类以及许多第三方开源库都提供了很多有单例行为的类。单例模式的实现方式有多种，但在实际使用时需要认真考量单例类的线程安全性、访问效率和懒加载属性，所有的限制和设计都要保证Singleton类仅仅被实例化一次。</p>
<h3 id="thanks-to">Thanks To:</h3>
<p><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">如何正确地写出单例模式</a><br>
<a href="http://blog.csdn.net/dmk877/article/details/50311791">Java设计模式—单例设计模式(Singleton Pattern)完全解析</a><br>
<a href="http://blog.csdn.net/zhengzhb/article/details/7331354">单例模式讨论篇：单例模式与垃圾回收</a><br>
<a href="https://blog.csdn.net/wufaliang003/article/details/81395411">Java中枚举的线程安全性及序列化问题</a><br>
<a href="https://juejin.im/post/6844903590545326088#heading-12">Kotlin下的5种单例模式</a></p>
]]></content>
    </entry>
</feed>