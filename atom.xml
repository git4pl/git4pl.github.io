<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://git4pl.github.io</id>
    <title>PL Notes</title>
    <updated>2020-11-18T01:55:37.498Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://git4pl.github.io"/>
    <link rel="self" href="https://git4pl.github.io/atom.xml"/>
    <subtitle>积跬步至千里，积小流成江海</subtitle>
    <logo>https://git4pl.github.io/images/avatar.png</logo>
    <icon>https://git4pl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, PL Notes</rights>
    <entry>
        <title type="html"><![CDATA[记部落帖子分享微信小程序封面图片合成的一些坑]]></title>
        <id>https://git4pl.github.io/post/WmBbWgxWB/</id>
        <link href="https://git4pl.github.io/post/WmBbWgxWB/">
        </link>
        <updated>2020-08-22T01:07:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="项目背景">项目背景</h3>
<p>58部落帖子详情的分享功能里分享到微信小程序，原有的封面图是由Server端下发的图片，若帖子是纯文本内容则Server下发的是58部落的广告默认图，这样分享出去的微信小程序封面图形势比较简单。为了丰富小程序封面图的内容，激起收到分享的用户点击进入小程序查看帖子的兴趣，本次项目针对这个小程序封面图进行优化设计。</p>
<p>新版本的分享到小程序的封面图设计是这样的：用帖子的素材合成一副新的封面图，要求封面图的顶部展示用户头像、名称以及帖子的浏览量。根据帖子是否带有图片，合成的封面图有两种不同的样式：<br>
1、带图片的帖子，取帖子第一张图片，在用户信息下面展示图片内容<br>
2、纯文本的帖子，取帖子正文内容展示在用户信息下面，最多显示6行帖子内容<br>
<img src="https://git4pl.github.io/post-images/1598063903913.png" alt="cover with picture" loading="lazy"><br>
<img src="https://git4pl.github.io/post-images/1598063965619.png" alt="cover with text" loading="lazy"></p>
<h3 id="实现方案">实现方案</h3>
<p>由于封面图中的元素都是Server动态下发的，尤其是图片需要下载后才能处理。一开始想到用UI控件来创建这个布局，可以很方便地利用控件的属性实现UI效果的细节，但是要生成的封面图没有Activity或者其他ViewGroup容器来承载它的绘制，最后采用Canvas + Paint来动态绘制，并将生成的Bitmap保存为本地文件。在实现这个UI效果的过程中遇到了一些技术上的小坑，记录下来以备后续复用。</p>
<h4 id="绘制圆形头像">绘制圆形头像</h4>
<p>利用Canvas绘制圆形图是很容易的事，通常可以使用这三种API在Canvas上实现圆形图：BitmapShader、ClipPath和PorterDuffXfermode。</p>
<h5 id="bitmapshager-图片渲染方式">BitmapShager 图片渲染方式</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个BitmapShader对象 使用传递过来的原Bitmap对象bmp
    BitmapShader bitmapShader = new BitmapShader(bmp, Shader.TileMode.CLAMP，Shader.TileMode.CLAMP);
 
    //paint设置shader
    paint.setShader(bitmapShader);
 
    //canvas画一个圆 使用设置了shader的paint
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);
   
    return newBitmap;
}
</code></pre>
<h5 id="clippath-裁剪区域">ClipPath 裁剪区域</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个Path对象，path添加一个圆 圆心半径均是r / 2， Path.Direction.CW顺时针方向
    Path path = new Path();
    path.addCircle(r / 2, r / 2, r / 2, Path.Direction.CW);
    //canvas绘制裁剪区域
    canvas.clipPath(path);   
    //canvas将图画到留下的圆形区域上
    canvas.drawBitmap(bmp, 0, 0, paint);
 
    return newBitmap;
}
</code></pre>
<h5 id="porterduffxfermode-图片混合模式">PorterDuffXfermode 图片混合模式</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);

    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);

    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);

    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);

    //canvas画一个圆形
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);

    //然后 paint要设置Xfermode 模式为SRC_IN 显示上层图像（后绘制的一个）的相交部分
    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));

    //canvas调用drawBitmap直接将bmp对象画在画布上 
    //因为paint设置了Xfermode，所以最终只会显示这个bmp的一部分 
    //也就是bmp的和下层圆形相交的一部分圆形的内容
    canvas.drawBitmap(bmp, 0, 0, paint);

    return newBitmap;
}
</code></pre>
<p>虽然上面三种方式都能绘出圆形图，但在实际项目需求中有一些坑需要注意。<br>
使用BitmapShader要注意图像缩放的处理，可以计算好缩放比例，使用Matrix对象设置缩放比例，然后将Matrix对象设置到BitmapShader对象中。<br>
使用Canvas的clipPath方法设置path，然后调用drawBitmap绘制的图形有锯齿现象，即使在paint中设置了抗锯齿参数也不能消除。<br>
使用Xfermode的方式，在实际项目中如果直接用上面代码里的写法将不能得到预期的圆形图，需要使用saveLayer方法将绘制操作保存到新的图层，将图像合成的处理放到离屏缓存中进行。</p>
<h4 id="文字居中绘制">文字居中绘制</h4>
<p>项目需求中要求顶部的用户头像和用户名水平方向居中对齐，这两者要居中对齐可以确定一个基准参考线，比如都关于顶部栏纵向的中线上下对称，头像关于该中线对称很容易实现，而要实现文字关于该中线的对称需要理解Android绘制文字的原理以及drawText方法的参数意义。<br>
<img src="https://git4pl.github.io/post-images/1598087533894.png" alt="" loading="lazy"><br>
Android的文字绘制是按如上图所示的基线绘制的，与之对应的实现是Paint类中的FontMetrics类的定义。</p>
<pre><code>public static class FontMetrics {
    /**
        * The maximum distance above the baseline for the tallest glyph in
        * the font at a given text size.
        */
    public float   top;
    /**
        * The recommended distance above the baseline for singled spaced text.
        */
    public float   ascent;
    /**
        * The recommended distance below the baseline for singled spaced text.
        */
    public float   descent;
    /**
        * The maximum distance below the baseline for the lowest glyph in
        * the font at a given text size.
        */
    public float   bottom;
    /**
        * The recommended additional space to add between lines of text.
        */
    public float   leading;
}
</code></pre>
<p>drawText()方法的x、y指定要绘制文字的基准点，该基准点是要绘制的文字基准线上的left、center、right三点之一（如下图），具体是哪个由paint的setTextAlign()方法设置，默认是left。<br>
<img src="https://git4pl.github.io/post-images/1598088667357.png" alt="" loading="lazy"><br>
要让所画的文字刚好相对于我们选定的参考线上下居中，即让文字的中心点落在参考线上，我们需要计算调用drawText()方法的y坐标，即上图中基线的y坐标值。可以将问题转化为计算中心点相对于基线的距离，文字中心点相对于其基线的距离可表示为 (top+bottom)/2 - bottom，在屏幕坐标系中top的实际值相对于基线是负数，所以前述距离公式为 (-top+bottom)/2 - bottom，简化后为 -top/2 - bottom/2，将此值加上参考线的y坐标值即为我们所求的y坐标。另外要注意paint.getFontMetrics()这个方法一定要在设置字体大小或者样式等一系列会影响字体的方法后调用，不然获取到的top和bottom值不准。</p>
<pre><code>Paint paint = new Paint();
paint.setTextSize(textSize);
paint.setAntiAlias(true);
Paint.FontMetrics fm = paint.getFontMetrics();
float top = fm.top;
float bottom = fm.bottom;
float baseLineY = (headH &gt;&gt; 1) - top / 2 - bottom / 2;
canvas.drawText(username, x, baseLineY, paint);
</code></pre>
<h4 id="绘制多行文字">绘制多行文字</h4>
<p>Canvas.drawText()只能绘制单行的文字，不能换行。它既不能在View的边缘自动折行显示，也不能在换行符\n处换行。而StaticLayout 支持换行，它既可以为文字设置宽度上限来让文字自动换行，也会在 \n 处主动换行。<br>
StaticLayout通过构造函数参数设置文字显示的属性。StaticLayout 的构造方法是 StaticLayout(CharSequence source, TextPaint paint, int width, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad)，其中参数里：</p>
<pre><code>width 是文字区域的宽度，文字到达这个宽度后就会自动换行；
align 是文字的对齐方向；
spacingmult 是行间距的倍数，通常情况下填 1 就好；
spacingadd 是行间距的额外增加值，通常情况下填 0 就好；
includepad 是指是否在文字上下添加额外的空间，来避免某些过高的字符的绘制出现越界。
</code></pre>
<h4 id="图片裁剪压缩">图片裁剪压缩</h4>
<p>微信分享SDK对分享到微信小程序的封面图大小有限制，要求体积不超过128KB，对图片分辨率没有明确要求，但是在不同机型以及平台终端上展示分享出去的小程序链接里发现微信SDK对封面图的尺寸比例是有要求的。小程序在显示分享的封面图时，图片的宽高比为5:4，不符合这个比例的尺寸，微信客户端将会对其进行裁剪。</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="https://blog.csdn.net/zly921112/article/details/50401976">android canvas drawText()文字居中</a><br>
<a href="https://www.jianshu.com/p/5136fbc0d301">StaticLayout支持文字绘制换行</a><br>
<a href="https://blog.csdn.net/TO_BE_RM/article/details/79859540">初识Android Bitmap压缩原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Canvas绘制圆形图]]></title>
        <id>https://git4pl.github.io/post/Vgyf9i2nb/</id>
        <link href="https://git4pl.github.io/post/Vgyf9i2nb/">
        </link>
        <updated>2020-08-16T10:35:52.000Z</updated>
        <content type="html"><![CDATA[<p>最近实现一个业务需求，要求将用户头像、用户名和正文内容合成为一张图片，以作为给微信小程序分享的封面图。通过一些ImageView控件是很容易实现圆形头像的，但这里需要创建一块画布，在Canvas上画出圆形头像，如果细节处理不好，可能达不到理想的效果。<br>
通常用Java代码绘制圆形图有三种方法，分别是使用BitmapShader、PorterDuffXfermode和ClipPath。这里记录一下这三种画圆形图的代码实现：</p>
<h4 id="bitmapshager-图片渲染方式">BitmapShager 图片渲染方式</h4>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个BitmapShader对象 使用传递过来的原Bitmap对象bmp
    BitmapShader bitmapShader = new BitmapShader(bmp, Shader.TileMode.CLAMP，Shader.TileMode.CLAMP);
 
    //paint设置shader
    paint.setShader(bitmapShader);
 
    //canvas画一个圆 使用设置了shader的paint
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);
   
    return newBitmap;
}
</code></pre>
<h4 id="porterduffxfermode-图片混合模式">PorterDuffXfermode 图片混合模式</h4>
<pre><code>    public Bitmap getCirleBitmap(Bitmap bmp) {
        //获取bmp的宽高 小的一个做为圆的直径r
        int w = bmp.getWidth();
        int h = bmp.getHeight();
        int r = Math.min(w, h);
 
        //创建一个paint
        Paint paint = new Paint();
        paint.setAntiAlias(true);
 
        //新创建一个Bitmap对象newBitmap 宽高都是r
        Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
        //创建一个使用newBitmap的Canvas对象
        Canvas canvas = new Canvas(newBitmap);
 
        //canvas画一个圆形
        canvas.drawCircle(r / 2, r / 2, r / 2, paint);
 
        //然后 paint要设置Xfermode 模式为SRC_IN 显示上层图像（后绘制的一个）的相交部分
        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
 
        //canvas调用drawBitmap直接将bmp对象画在画布上 
        //因为paint设置了Xfermode，所以最终只会显示这个bmp的一部分 
        //也就是bmp的和下层圆形相交的一部分圆形的内容
        canvas.drawBitmap(bmp, 0, 0, paint);
 
        return newBitmap;
    }
</code></pre>
<h4 id="clippath-裁剪区域">ClipPath 裁剪区域</h4>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个Path对象，path添加一个圆 圆心半径均是r / 2， Path.Direction.CW顺时针方向
    Path path = new Path();
    path.addCircle(r / 2, r / 2, r / 2, Path.Direction.CW);
    //canvas绘制裁剪区域
    canvas.clipPath(path);   
    //canvas将图画到留下的圆形区域上
    canvas.drawBitmap(bmp, 0, 0, paint);
 
    return newBitmap;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于类加载的时机与过程]]></title>
        <id>https://git4pl.github.io/post/OH92heMH4/</id>
        <link href="https://git4pl.github.io/post/OH92heMH4/">
        </link>
        <updated>2020-07-19T02:54:31.000Z</updated>
        <content type="html"><![CDATA[<p>思考以下代码的输出结果：</p>
<pre><code>public class Singleton {
    private static Singleton instance = new Singleton();
    public static int count1;
    public static int count2 = 0;
    private Singleton() {
        count1 ++;
        count2 ++;
    }

    public static Singleton getInstance() {
        return instance;
    }
｝

public class Test {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println(&quot;count1 = &quot; + Singleton.count1);
        System.out.println(&quot;count2 = &quot; + Singleton.count2);
    }
}
</code></pre>
<blockquote>
<p>错误答案<br>
count1 = 1<br>
count2 = 1</p>
</blockquote>
<blockquote>
<p>正确答案<br>
count1 = 1<br>
count2 = 0</p>
</blockquote>
<p>这个问题就是牵涉到类的加载与过程，虚拟机定义了以下六种情况，如果类未被初始化，则会进行初始化：<br>
1、创建类的实例<br>
2、访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。<br>
3、访问类的静态方法<br>
4、反射如(Class.forName(&quot;my.xyz.Test&quot;))<br>
5、当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化<br>
6、虚拟机启动时，定义了main()方法的那个类先初始化</p>
<p>我们来分析以下上述代码的执行情况：</p>
<ol>
<li>main()方法 Test类初始化</li>
<li>main()方法第一句：访问Singleton的getInstance()静态方法 Singleton类初始化，此时按照代码执行顺序进行静态成员的初始化默认值<br>
instance = null<br>
count1 = 0<br>
count2 = 0</li>
<li>按照代码执行顺序为类的静态成员赋值：<br>
private static Singleton instance = new Singleton(); instance调用Singleton的构造方法,调用构造方法后 count1 = 1,count2 = 1<br>
public static int count1; count1没有进行赋值操作，所以count1 = 1<br>
public static int count2 = 0; count2进行赋值操作，所以count2 = 0</li>
<li>main()方法第二句：访问Singleton的count1变量，由于count1没有赋初始值，所以count1 = 1</li>
<li>main()方法第三句：访问Singleton的count2变量，由于count2赋了初始值 0，所以count2 = 0</li>
</ol>
<p>如果我们把Singleton代码执行顺序变化一下：</p>
<pre><code>public class Singleton {
    public static int count1;
    public static int count2 = 0;
    private static Singleton instance = new Singleton();

    private Singleton() {
        count1++;
        count2++;
    }

    public static Singleton getInstance() {
        return instance;
    }

}
</code></pre>
<p>此时输出结果就为:</p>
<blockquote>
<p>count1 = 1<br>
count2 = 1</p>
</blockquote>
<p>如果改为如下代码，那么运行情况又是怎样：</p>
<pre><code>public class Singleton {
    Singleton(){
        System.out.println(&quot;Singleton construct&quot;);
    }

    static {
        System.out.println(&quot;Singleton static block&quot;);
    }

    public static final int COUNT = 1;

}

public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;count = &quot; + Singleton.COUNT);
    }
}
</code></pre>
<p>运行结果为：</p>
<blockquote>
<p>count = 1</p>
</blockquote>
<p>由于常量在编译阶段会存入相应类的常量池当中，所以在实际调用中Singleton.COUNT并没有直接引用到Singleton类，因此不会进行Singleton类的初始化，所以输出结果为 count = 1</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="https://www.jianshu.com/p/27eb533b29f7">Kotlin:由object和companion object创建的单例模式引发的思考</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式笔记]]></title>
        <id>https://git4pl.github.io/post/NUANIynJT/</id>
        <link href="https://git4pl.github.io/post/NUANIynJT/">
        </link>
        <updated>2020-07-11T01:28:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="开篇小引">开篇小引</h3>
<p>在上大学时我做了一个小项目是关于人机交互的应用，我负责实现的部分是通过语音识别技术接收用户的问题，然后在数据库中检索预置的问题答案，并由我们的应用“说”出来对用户的问题进行解答。当时我就由这个应用的交互模式产生了一个小小的想法，我希望有一天可以实现一个很简单方便的东西能让中国的老奶奶和美国甚至更多其他国家的老奶奶坐在一起轻松愉快地聊天，完全不用担心各自语言的障碍，这涉及到语音识别和机器翻译等诸多技术，现在顶级的科技公司已经在各种细分的技术上有研究实践了。我的那个小想法其实与本篇博客的主题——适配器模式——有相似的实现思想。</p>
<h3 id="定义及特点">定义及特点</h3>
<p><strong>适配器模式将一个类的接口转换成客户期望的另一个接口，使得原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</strong></p>
<p>适配器模式可以通过创建适配器进行接口转换，让不兼容的接口变得能兼容。这可以让客户从实现的接口解耦，如果在一段时间之后，我们想要改变接口，适配器可以将改变的部分封装起来，客户端就不必为了应对不同的接口而每次跟着修改。</p>
<p>适配器模式涉及到三种角色：<br>
●  目标接口（Target）——定义客户期望的与特定领域相关的接口<br>
●  适配者类（Adaptee）——定义一个已经存在的接口，是需要适配的类<br>
●  适配器类（Adapter）——通过包装一个需要适配的对象，把原接口转换成目标接口</p>
<h3 id="适用场景">适用场景</h3>
<p>以下情况可使用适配器模式：<br>
√  系统需要使用现有的类，而这些类的接口不符合系统的接口<br>
√  想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作<br>
√  两个类所做的事情相同或相似，但是具有不同接口的时候<br>
√  旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候<br>
√  使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能</p>
<h3 id="实现方式">实现方式</h3>
<p>在GoF的设计模式中，适配器模式有两种可行的实现方式：<strong>类适配器</strong>和<strong>对象适配器</strong>，类适配器使用多重继承对一个接口与另一个接口进行匹配，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431276853.png" alt="" loading="lazy"><br>
对象适配器依赖于对象组合，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431299777.webp" alt="" loading="lazy"><br>
类适配器因为需要Adapter类同时继承自Target类和Adaptee类，所以只能在支持多重继承的语言中实现（Java虽然不支持多继承，但可以通过实现接口implements interface来实现类适配器，如下代码示例）；对象适配器模式充满着良好的OO设计原则：使用对象组合，以修改的接口包装被适配者，这样被适配者的任何子类，都可以搭配着适配器使用。</p>
<pre><code>public interface Target {
    /**
     * 这是适配者类Adaptee也有的方法
     */
    public void sampleOperation1(); 
    /**
     * 这是适配者类Adapteee没有的方法
     */
    public void sampleOperation2(); 
}

public class Adaptee {
    void sampleOperation1(){}
}

public class Adapter extends Adaptee implements Target {
    /**
     * 由于适配者类Adaptee没有方法sampleOperation2()
     * 因此适配器类Adapter补充上这个方法
     */
    @Override
    public void sampleOperation2() {
        //实现相关的代码
    }
}
</code></pre>
<p>类适配器和对象适配器有不同的权衡。<br>
类适配器：<br>
●  用一个具体的Adapter类对Adaptee和Target进行匹配，这使得Adapter不能和Adaptee的子类一起工作<br>
●  使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的子类<br>
●  仅仅引入了一个对象，并不需要额外的指针以间接得到Adaptee<br>
对象适配器：<br>
●  允许一个Adapter与多个Adaptee（即Adaptee本身以及它的所有子类）同时工作，Adapter也可以一次给所有的Adaptee添加功能<br>
●  重定义Adaptee的行为比较困难（这需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身）</p>
<h3 id="适配器小结">适配器小结</h3>
<p>使用适配器的优点：<br>
1、通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。<br>
2、复用了现存的类，解决了现存类和复用环境要求不一致的问题。<br>
3、将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。<br>
4、一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>
<p>使用适配器的缺点：<br>
过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/09/2582485.html">设计模式学习笔记-适配器模式</a><br>
<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">《JAVA与模式》之适配器模式</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[真的理解单例模式吗？]]></title>
        <id>https://git4pl.github.io/post/TjHrGm886/</id>
        <link href="https://git4pl.github.io/post/TjHrGm886/">
        </link>
        <updated>2020-07-07T12:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>单例模式是设计模式中最常用也最简单的一种模式，相信很多程序员小伙伴在求职面试过程中都被面试官问到过单例模式。虽然它的定义和类结构非常简单，但是要实现一个完全没有问题的单例模式却没有那么简单；即使能写出一个合格有效的单例模式，要把其中的逻辑原理讲述清楚令面试官满意也不容易。</p>
<p>单例模式的实现方式有很多种，不同的实现方式能适应不同的应用场景。单线程中的单例比较简单，单例模式的复杂性主要是在多线程并发环境下要充分考虑对象访问的性能、线程安全等问题。如何实现高性能、线程安全、防攻击的单例模式？对于线程安全的单例实现方式，它们分别是怎样保证线程安全的？DCL的单例实现中synchronized和volatile关键字分别有什么作用？带着这些问题我再深入学习一下单例模式。</p>
<h3 id="定义及特点">定义及特点</h3>
<p>单例模式确保一个类只有一个实例，并提供一个全局访问方法。其类结构图如下：<br>
<img src="https://git4pl.github.io/post-images/1594123603857.jpeg" alt="" loading="lazy"></p>
<p>单例模式是对象创建型模式，要实现一个单例类需满足以下几个要素：<br>
（1） 一个私有的构造方法<br>
（2） 一个指向自己实例的私有的静态引用<br>
（3） 一个返回自己实例的公有的静态方法<br>
所以一个单例类应该类似下面的伪代码：</p>
<pre><code>public class Singleton {
    private Singleton() {} //私有的构造方法
    private static Singleton singleton; //指向自己实例的私有静态引用
    public static Singleton getInstance() { //返回自己实例的公有静态方法
        …… //创建本单例类的唯一实例，并赋值给私有静态引用
        return singleton;
    }
}
</code></pre>
<p>其实，按照定义的方式写出的单例模式并不能保证单例对象的唯一，可以通过以下方法破坏一个单例类的实例唯一性：</p>
<ul>
<li>使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。</li>
<li>如果单例的类实现了cloneable，那么还是可以拷贝出多个实例的。</li>
<li>Java中的对象序列化也有可能导致创建多个实例。</li>
<li>使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。</li>
</ul>
<p>所以，如果要考虑单例类的防攻击，在实现时还需要做到防止反序列化、防止反射、防止克隆。</p>
<pre><code>//readResolve method to preserve Singleton property
private Object readResolve() throws ObjectStreamException {
    return INSTANCE;
}

//防止反射调用后创建新的Singleton实例
private static boolean flag = false;  
private Singleton() {
    synchronized(Singleton.class) {
        if (!flag) {
            flag = true;  
        } else {  
            throw new RuntimeException(&quot;单例模式被侵犯！&quot;);  
        }  
    }  
}

//防止克隆产生新的实例
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException(&quot;Cannot clone instance of this class&quot;);
}
</code></pre>
<p>因为单例类对象的生命周期是从实例被创建到应用程序结束，所以一个高质量的单例类还需要满足以下特点：<br>
√ 懒加载    ——  在需要时才创建单例类的实例<br>
√ 线程安全 —— 应保证在多线程环境下访问单例类不会创建多个实例<br>
√ 高性能    —— 获取单例对象的过程中应减少同步的消耗</p>
<h3 id="适用场景">适用场景</h3>
<p>由于单例类保证一个类只有一个实例，并且由此表现出了一些其他优点，使得单例模式是在开发中比较常用的一种设计模式。根据单例类的优点，单例模式通常适用于以下场景的类创建：<br>
● 需要频繁实例化然后销毁的对象<br>
● 创建对象时耗时过多或者耗资源过多，但又经常用到的对象<br>
● 有状态的工具类对象<br>
● 频繁访问数据库或文件的对象<br>
● 需要保证数据一致性的配置文件类或工具类对象</p>
<h3 id="实现方式">实现方式</h3>
<p>根据单例模式的思想以及单例类能解决的问题，单例模式的实现方式有多种，不同的实现方式可能在单例对象的实例化时机、线程安全性和访问性能方面有所不同。下面分别整理各种实现方式及其优缺点。</p>
<h4 id="饿汉式单例">饿汉式单例</h4>
<pre><code>public class Singleton {  
    private static Singleton instance=new Singleton();  
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;  
    }
} 
</code></pre>
<p>这种单例实现方法之所以被称为饿汉式是因为它利用JVM机制在单例类被加载时实例化。其实例化时机比较早，所以没有实现懒加载（Lazy Loading），即使这个实例在应用的生命周期内没有被使用到，也会因为已经被加载而占用一定的内存空间；另外这种实现方式也无法给单例的实例化过程传入必须的参数。饿汉式的实现方式比较简单，在单例类被加载到内存时就完成了实例化，避免了线程同步的问题；另外因为实例没有被使用而造成的内存浪费问题可以忽略，饿汉式单例的实现方式是被推荐使用的。<br>
饿汉式单例的实例化过程还有一种写法，不过本质上也是利用JVM的类加载机制，只是语法的应用而已，如下：</p>
<pre><code>private static Singleton instance = null;  
static {  
   instance = new Singleton();  
}
</code></pre>
<h4 id="懒汉式单例">懒汉式单例</h4>
<p>懒汉式单例的实现目的就是为了达到单例类的懒加载，即在单例类第一次被使用到的时候实例化该单例类，对应到单例类实现的基本要素就是在返回单例类实例的公有静态方法中去实例化单例对象。懒汉式单例的最直接最简单的实现如下：</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
<p>上述实现方式在实际项目中并不可取，因为它存在线程安全问题，当有多个线程去调用getInstance()方法获取Singleton的实例时，有可能得到的不是同一个对象，即有可能每个线程访问getInstance()方法时各自创建一个Singleton实例。要解决这种实现方式的线程安全问题，可以考虑加锁进行同步。</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {};
    public static synchronized Singleton getInstance() {
        if (instance == null) {
	    instance = new Singleton();
	}
	
        return instance;
    }
}
</code></pre>
<p>上面的改进是在getInstance()方法上加锁进行同步，这样虽然解决了线程安全的问题，但又带来了访问效率低下的问题。每个线程在访问getInstance()方法获得类实例的时候，都要进行同步操作，而其实这个方法只需执行一次实例化代码就够了，只要单例对象还存在就可以直接return给访问者。对懒汉式单例进一步优化得到了既能保证线程安全又能有较高的访问效率的<strong>双重检查锁(Double Checked Locking)实现</strong>。</p>
<h4 id="双重检测的单例">双重检测的单例</h4>
<pre><code>public class Singleton {
    private static volatile Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance(){
         if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
    }
}
</code></pre>
<p>双重检查锁的实现方式是比较健壮的懒汉式单例实现，有两个问题需要理解：<br>
1、双重检查有什么意义<br>
双重检查就是在getInstance()方法中有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检查一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检查的话就会生成多个实例了。<br>
假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p>
<p>2、静态引用instance前的volatile关键字有何作用<br>
主要在于instance = new Singleton();这句并非是一个原子操作，在JVM中这句话大概做了下面 3 件事情：<br>
① 分配一块内存空间M<br>
② 调用 Singleton 的构造函数在内存M上创建对象<br>
③ 将M的地址赋值给 instance 变量（执行完这步 instance 就为非 null 了）<br>
但是在JVM的即时编译器中存在指令重排序的优化，也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 ①-②-③ 也可能是 ①-③-②。如果是后者，则在 ③ 执行完毕、② 未执行之前，线程二执行到同步快外的检查，这时 instance 已经是非 null 了，所以线程二会直接返回 instance，但却没有完成初始化。<br>
<img src="https://git4pl.github.io/post-images/1603974948705.png" alt="" loading="lazy"></p>
<p>volatile 修饰符具有禁止指令重排序优化的特性，也就是说在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 ①-②-③ 或者 ①-③-② 之后，不存在执行到 ①-③ 然后取到值的情况。从「先行发生原则（happens-before）」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<h4 id="静态内部类实现单例">静态内部类实现单例</h4>
<pre><code>public class Singleton{
    private Singleton() {}
    private static class SingletonHolder{
        private static Singleton instance=new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
</code></pre>
<p>通过在类中创建一个静态内部类来实现单例模式也是利用了JVM的类加载机制保证只创建一份实例，同时与饿汉式单例一样具有线程安全性，而且客户在获取这个单例类实例的时候不会进行同步，没有性能缺陷，也不依赖 JDK 版本。静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时调getInstance()方法，才会装载SingletonHolder类实例化Singleton，这样就实现了单例类的懒加载。<br>
由于使用静态内部类实现单例避免了线程不安全的问题，并且有较高的访问效率以及实现了延迟加载，这种方式是值得推荐的单例实现方式，当然这种方式与饿汉式单例一样不能传入参数。</p>
<h4 id="枚举实现单例">枚举实现单例</h4>
<pre><code>public enum Singleton {
    INSTANCE;
    private Singleton() {}
    public void method() {
    }
 }
</code></pre>
<p>从Java1.5版本起，创建单例可以使用简洁的枚举类型，我们直接通过Singleton.INSTANCE来访问实例。对于枚举类型，编译器会自动帮我们创建一个final类型的类继承自Enum类，并且该类中的几个属性被定义成static final，在static代码块中初始化那些属性，枚举类型通过Java类加载机制和初始化过程保证线程安全；而且通过jvm规范保证序列化，枚举还能防止反序列化或者反射攻击导致创建新的实例。《Effective Java》中更是说明单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<h3 id="kotlin单例实现">Kotlin单例实现</h3>
<p>用Kotlin语言实现单例模式很简单，使用object关键字代替class关键字定义的类就是一个单例类。</p>
<pre><code>object Singleton {
    fun sayHello() {
        Log.d(&quot;TAG&quot;, &quot;Hello Kotlin&quot;)
    }

    init {
        Log.d(&quot;TAG&quot;, &quot;initialize the Kotlin class&quot;)
    }
}
</code></pre>
<p>将Kotlin实现的单例类的字节码转成Java代码，如下图：<br>
<img src="https://wos.58cdn.com.cn/IjGfEdCbIlr/ishare/e38f8dd9-af69-42be-ad30-1fa51ee77ef2kotlin_singleton.png" alt="kotlin_singleton.png" loading="lazy"></p>
<p>可见，上面的Kotlin单例类对应的Java代码其实是Java版本的饿汉式单例。单例对象在静态代码块中创建，单例类的静态引用被定义成public static final，因为在Java代码中访问这个单例对象时会调用它。如下分别是Kotlin和Java代码访问这个单例的方法：</p>
<pre><code>//Kotlin 调用
Singleton.sayHello()

//Java 调用
Singleton.INSTANCE.sayHello();
</code></pre>
<p>用object关键字声明的单例类无法给单例的实例化过程传入参数，可借助Kotlin的伴生对象companion object来实现带参数的单例，因为伴生对象中的方法和属性被绑定到类上，通过类名直接访问，它将在类被加载的时候初始化。</p>
<p>如下用伴生对象带参数实现双重检测的单例类：</p>
<pre><code>class Singleton private constructor(context: Context) {
    companion object {
        @Volatile
        private var instance: Singleton? = null
        fun getInstance(context: Context): Singleton {
            if (instance != null) {
                return instance as Singleton
            }

            return synchronized(this) {
                if (instance != null) {
                    instance as Singleton
                } else {
                    val created = Singleton(context)
                    instance = created
                    created
                }
            }
        }
    }
}
</code></pre>
<p>利用companion object还可以实现其他类型的单例模式的Kotlin版本。</p>
<h3 id="单例模式小结">单例模式小结</h3>
<p>单例模式是类结构和模式思想最简单的一种设计模式，也是实际项目在被使用最多的一种模式，Android SDK的许多类以及许多第三方开源库都提供了很多有单例行为的类。单例模式的实现方式有多种，但在实际使用时需要认真考量单例类的线程安全性、访问效率和懒加载属性，所有的限制和设计都要保证Singleton类仅仅被实例化一次。</p>
<h3 id="thanks-to">Thanks To:</h3>
<p><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">如何正确地写出单例模式</a><br>
<a href="http://blog.csdn.net/dmk877/article/details/50311791">Java设计模式—单例设计模式(Singleton Pattern)完全解析</a><br>
<a href="http://blog.csdn.net/zhengzhb/article/details/7331354">单例模式讨论篇：单例模式与垃圾回收</a><br>
<a href="https://blog.csdn.net/wufaliang003/article/details/81395411">Java中枚举的线程安全性及序列化问题</a><br>
<a href="https://juejin.im/post/6844903590545326088#heading-12">Kotlin下的5种单例模式</a></p>
]]></content>
    </entry>
</feed>