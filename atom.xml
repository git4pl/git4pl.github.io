<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://git4pl.github.io</id>
    <title>PL Notes</title>
    <updated>2021-01-20T08:27:18.133Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://git4pl.github.io"/>
    <link rel="self" href="https://git4pl.github.io/atom.xml"/>
    <subtitle>积跬步至千里，积小流成江海</subtitle>
    <logo>https://git4pl.github.io/images/avatar.png</logo>
    <icon>https://git4pl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, PL Notes</rights>
    <entry>
        <title type="html"><![CDATA[关于背压的理解]]></title>
        <id>https://git4pl.github.io/post/imXjzp6FH/</id>
        <link href="https://git4pl.github.io/post/imXjzp6FH/">
        </link>
        <updated>2021-01-20T08:19:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="背压是什么">背压是什么？</h3>
<p>初次听到“背压”这个词感觉像是“天王盖地虎”这样的行话，不知道是什么，感觉很高深的样子。</p>
<p>网络上有很多关于背压的文章，但对背压这个词的解释各不相同。有的人把它看作一个需要避免的问题，或者程序的异常，描述语言类似于“...发生了背压”；有的人说背压是解决这种在异步场景中被观察者发送事件速度远快于观察者的处理速度的问题的策略；还有的人认为背压是具有解决这种问题的能力或机制，比如说某某库支持背压或不支持背压。</p>
<p>维基百科上对 Backpressure 的定义是：Backpressure is a resistance or force opposing the desired flow of fluid through pipes（背压是抵抗所需的流体通过管道流动的阻力或反作用力），借用到软件领域它的定义应该是：Backpressure is a resistance or force opposing the desired flow of data through software。</p>
<p>国内有位Android大咖<a href="https://www.zhihu.com/people/rengwuxian">扔物线</a>在知乎上的一篇关于背压的回答我比较赞同，他说 Backpressure 其实是一种现象：在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure 出现。响应式编程中的【背压（Backpressure）】概念来源于流体力学的比喻，也和其他工程领域的背压概念相似，比如在管道运输中，气流或液流由于管道突然变细、急弯等原因导致由某处出现了下游向上游的逆向压力，这种情况称为 Backpressure。背压是我们在软件开发中经常遇到并且有时不得不处理的问题，但这个词以及表达的现象并没有被正确地理解和认识。背压并不是一种机制，也不是一种策略，背压现象中关键是下游的 Buffer 溢出。</p>
<h3 id="背压的例子">背压的例子</h3>
<h4 id="读写文件">读写文件</h4>
<p>一般写文件比读文件要慢，假设一个磁盘驱动有效的读文件速度是150MB/s，而写文件速度是100MB/s，如果要以最快的速度将文件读入内存，同时又以最快的速度将其写回磁盘，则必须每秒缓冲50MB，这样内存将被不断被堆积，在输入文件被完全读取之前，内存中还有大量的数据没有被写入文件。假设要读入一个6GB的文件然后将它写入磁盘，在你读完全部文件时，还有2GB的内容等待写入。</p>
<pre><code>6 GB / 150 MB/s = 40 s
150 MB - 100 MB = 50 MB
50 MB x 40 = 2 GB !!!
</code></pre>
<p>这将浪费很多的内存，在一些系统上可能超出了可用内存，最终产生OutOfMemory Exception，这就是由于写文件速度慢于读文件速度产生了背压问题。</p>
<h4 id="服务器通信">服务器通信</h4>
<p>另一个关于背压问题的例子是服务器间的通信问题。在普遍采用的微服务架构中，各个服务器的职责一般是独立分散的，当一台服务器向另一台服务器发送请求的速度快于后者处理请求的速度时，通常会出现背压。<br>
如果服务器A向服务器B发送100个rps（每秒请求数），但服务器B只能处理75个rps，那么对于服务器B就有25个rps的富余。此时服务器B可能会落后，因为它需要处理这些请求，或者还需要与下游的其他服务器通信。这是由于服务器处理能力的差异，导致上下游通信的服务器在处理请求时产生了背压问题。</p>
<figure data-type="image" tabindex="1"><img src="https://git4pl.github.io/post-images/1611130854773.gif" alt="" loading="lazy"></figure>
<h4 id="渲染ui">渲染UI</h4>
<p>在渲染UI方面也经常发生背压的现象，当程序无法以所需的速度渲染时，就会发生背压，比如Android App的卡顿现象是由于应用程序的渲染速度没有达到60fps。</p>
<h3 id="如何解决背压">如何解决背压</h3>
<p>可以看出背压现象在我们的程序开发中普遍存在，而且各个场景下处理背压的思路都差不多。除了扩展可用的计算资源外，如何处理背压问题可以概括为三种可能的选择：</p>
<ul>
<li>控制生产者产生数据的速度以适应消费者的响应速度</li>
<li>缓存临时产生的大量数据</li>
<li>丢弃上游发出的事件（可能有多种策略）</li>
</ul>
<p><strong>控制</strong>生产者可能是处理背压问题的最优选择，如果这种方案可行的话，它只需要考虑设计好控制机制，而不会有内存和其他资源的开销。在数据消费端不需要额外的内存来缓存数据，也不需要顾虑丢弃数据。不幸的是控制生产者产生数据并不总是可行，比如数据的输入是用户操作，我们不能控制程序系统之外的数据生产者。</p>
<p><strong>缓存</strong>是大多数背压问题的解决方式。Backpressure 和 Buffer 是一对相生共存的概念，一方面只有设置了 Buffer，才有 Backpressure 出现；另一方面只要设置了 Buffer，一定存在出现 Backpressure 的风险。使用缓存时要考虑，缓冲区的增长速度有可能在相当长的一段时间内超过它的消耗速度吗？如果缓冲区是无界的，那么缓冲区可能是危险的，这意味着对缓冲区没有大小或时间限制。</p>
<p><strong>丢弃</strong>是最后一种策略，它也经常与缓存相结合。比如基于时间的采样，每秒丢弃10%的数据。丢弃的具体策略有多种。</p>
<h3 id="rxjava中如何解决背压">RxJava中如何解决背压？</h3>
<p>RxJava是一个使用可观察序列组成异步和基于事件的程序的库，在RxJava中会经常遇到一种情况就是被观察者发送消息太快以至于它的操作符或订阅者不能及时处理相关的消息，那么随之而来的问题就是如何处理这些不断累积的未处理的消息？</p>
<p>RxJava从1.x到3.x不同版本对这个问题的应对方式和支持力度不同，很多文章说RxJava 1.x不支持背压，根据这些文章的描述，我理解不支持背压说的是RxJava 1.x版本的Observable不能直接添加解决背压的策略，而RxJava 2.x以后版本的Flowable可以通过参数设置背压策略，其实RxJava 1.x版本提供了支持解决背压的其他操作符，比如onBackpressureBuffer、onBackpressureDrop和onBackpressureLatest。在使用Observable发射数据后不使用解决背压的操作符进行处理，或者在使用了背压策略后观察者仍不能及时处理上游的数据的情况下，可能会抛出MissingBackpressureException表示发生了背压问题。</p>
<p>Observable 数据流可分为两种类型：Cold 和 Hot Observable，并不是严格的概念区分，它们只是对于两类被观察的数据流的形象描述。</p>
<ul>
<li>Cold Observable：指的是被观察者发射数据的时机和频率由观察者决定，每个观察者都能接收到完整的事件序列，cold observable的示例包括数据库查询、文件检索和Web请求等</li>
<li>Hot Observable：指的是被观察者在被创建后就立即发射数据，观察者会在建立对被观察者的订阅关系时接收到数据，它不能干涉hot observable发射数据的行为，示例包括鼠标或键盘事件、系统事件等</li>
</ul>
<h4 id="recative-pull">Recative Pull</h4>
<p>用<em>控制</em> 的方式解决背压问题可以通过阻塞被观察者的线程来实现，这有个缺点就是违背了Rx的响应式和非阻塞的模式。如果被观察者生产数据和观察者接收数据都在同一个线程，这就天然地形成了通过阻塞方式来解决背压问题。RxJava 提供了一种响应式拉取（Reactive Pull）的方式实现异步线程阻塞以解决背压问题，通过实现Subscriber类来订阅Observable，在 subscriber 的 onStart()方法中调用Subscriber.request(n) 方法，其中n表示观察者在下次调用request方法前被观察者可发送的最大数据量。在subscriber 的 onNext()中处理完已发送的数据后，可以再次调用request()方法，以指示Observable再发射一些数据。</p>
<pre><code>someObservable.subscribe(new Subscriber&lt;T&gt;() {
    @Override
    public void onStart() {
      request(1);
    }

    @Override
    public void onCompleted() {
      // gracefully handle sequence-complete
    }

    @Override
    public void onError(Throwable e) {
      // gracefully handle error
    }

    @Override
    public void onNext(T n) {
      // do something with the emitted item &quot;n&quot;
      // request another item:
      request(1);
    }
});
</code></pre>
<h4 id="rxjava背压操作符">RxJava背压操作符</h4>
<p>Cold Observables非常适合采用响应式拉取方式解决背压，Cold Observable可能会被转化成Hot Observable，而Hot Observable不适合用响应式拉取的方式。RxJava 提供了一些流控策略的操作符解决背压，这些操作符的基本原理都是采用<em>缓存</em>或<em>丢弃</em>策略，来调节被观察者发射数据的频率。</p>
<h5 id="buffer">buffer</h5>
<p>buffer 操作符可以使观察者以固定的时间间隔周期性地接收到被观察者发送的数据，被观察者发射的数据不会被丢失。<br>
<img src="https://git4pl.github.io/post-images/1611130890101.png" alt="" loading="lazy"></p>
<h5 id="window">window</h5>
<p>window 与 buffer 类似，一个窗口类型可以让被观察者以固定的时间间隔发射可观察到的窗口，还可以选择在每次从可观察源收集特定数量的数据项时发出一个新窗口。<br>
<img src="https://git4pl.github.io/post-images/1611130927060.png" alt="" loading="lazy"></p>
<h5 id="samplethrottlelast">sample(throttleLast)</h5>
<p>sample 操作符可以从被观察者发射的数据序列中周期性地获取数据，并且取观察周期内最近发射的数据。<br>
<img src="https://git4pl.github.io/post-images/1611130939445.png" alt="" loading="lazy"></p>
<h5 id="throttlefirst">throttleFirst</h5>
<p>与 sample 类似周期地获取数据，但是取在一个观察周期后面发射的第一个数据。<br>
<img src="https://git4pl.github.io/post-images/1611130949480.png" alt="" loading="lazy"></p>
<h5 id="debounce">debounce</h5>
<p>debounce 操作符可以去除发射频率过快的数据，所以它获取的是被观察者发射的数据序列中没有后继者的那些数据。<br>
<img src="https://git4pl.github.io/post-images/1611130909637.png" alt="" loading="lazy"></p>
<h4 id="flowable">Flowable</h4>
<p>在RxJava 2.0 版本中加入了 Flowable，为了解决RxJava 1.x中 Observable 不直接支持背压的问题。Flowable 支持背压是通过在 create 方法中传入 BackpressureStrategy 指定解决背压的策略，并且提供了默认的缓存大小为128。BackpressureStrategy是一个枚举类型，具体策略的实现原理根据字面意思与上面对应的操作符类似。</p>
<pre><code>public enum BackpressureStrategy {
    //不指定背压策略
    MISSING,
    //出现背压就抛出异常
    ERROR,
    //指定无限大小的缓存池，此时不会出现异常，但无限制大量发送会发生OOM
    BUFFER,
    //如果缓存池满了就丢弃掉之后发出的事件
    DROP,
    //在DROP的基础上，强制将最后一条数据加入到缓存池中
    LATEST
}
</code></pre>
<h3 id="总结">总结</h3>
<p>解决背压的策略并不能消除过度生产或者消费不足的问题，它只是把问题转移到一个可以更好处理的操作链上。再次理解背压可以总结为：</p>
<ol>
<li>
<p>只要上游生产速度不会快到让系统崩溃或者应用场景不可接受，那么不用设置 Buffer，从而也就不用考虑 Backpressure发生。</p>
</li>
<li>
<p>只有上游生产速度可能会快到让系统崩溃，并且事件是可以丢弃的，才需要设置 Buffer。当 Buffer 有上限的时候，Backpressure 也就有可能出现；一旦 Backpressure 出现，只能选择丢弃，只是具体的丢弃策略可以根据需求而定（全部丢弃、只保留最新的一个而丢弃其余的等等，丢弃根本基本原则）。</p>
</li>
<li>
<p>如果上游生产速度可能会快到把系统搞崩溃，而事件也不可丢弃，这个时候可能修改程序的设计了：修改代码设计来规避风险，或者修改软件设计、通过让步的方式来从根源上避免问题发生。但这已经不是 Buffer 或者 Backpressure 能解决的问题了。</p>
</li>
</ol>
<h3 id="refers-to">Refers To</h3>
<p><a href="https://www.zhihu.com/question/49618581">如何形象的描述反应式编程中的背压(Backpressure)机制？</a><br>
<a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">Backpressure</a><br>
<a href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7">Backpressure explained — the resisted flow of data through software</a><br>
<a href="https://proandroiddev.com/rxjava-backpressure-and-why-you-should-care-369c5242c9e6">RxJava Backpressure and why should you care?</a><br>
<a href="https://juejin.cn/post/6844903473016733710">关于 RxJava 背压</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我们一起走过2020]]></title>
        <id>https://git4pl.github.io/post/XT99my5Cu/</id>
        <link href="https://git4pl.github.io/post/XT99my5Cu/">
        </link>
        <updated>2021-01-19T11:28:59.000Z</updated>
        <content type="html"><![CDATA[<p>2020年终于过去了，这一年我们经历了很多事，有喜乐也有烦扰，从宏观环境到我们个人周遭都发生了很多事，在2020年的最后一天总结回顾一下这一年发生在我身边的大小故事吧。</p>
<h2 id="关于我个人">关于我个人</h2>
<p>关于我个人，在2020这一年里也是起起伏伏有喜有忧，对我个人而言最重要的就是家和事业。</p>
<p>1月份回到老家完成我的婚礼，完成婚礼就标志我正式有了自己的家，家里有了妻子有了儿子，他们是我最爱的人也是最爱我的人；10月份我回老家把老妈接到北京来住，她很开心，一直想跟我一起住，这一年是我和妈妈一起朝夕相处生活的时间最长的时候。有我老妈包括丈母娘来和我们小家一起住，我的这个家才圆满了，叫做一家老小其乐融融！</p>
<p>过完春节在全国疫情还不明朗的情况下，我独自从老家回到北京开始工作，2、3月份都是在家里远程办公，4月份疫情减轻了，回到公司办公。而这时我遭遇了职业生涯的第一次裁员，公司倒是按正规的补偿方案给予被裁员工补偿的，但是在全国乃至全世界疫情没有得到有效控制经济环境不好的情况下，丢掉工作是一件让人忧心的事，加之当时正值我孩子要出生的时候，的确给我不小的压力。遇到困难只有直面问题认真对待才不会被困难吓倒，我镇定下来在5月份一个月认真准备面试，积极寻找工作机会，终于在6月初入职了新的公司。</p>
<p>在经济大环境不好的条件下经历过裁员其实给了我不小的成长，懂得了一定要在职业上有圈子、有知识技能的沉淀，同时还要不断学习新技术。做技术的其实不用太担心工作机会缺少，只要练好基本功，再加上一些人脉资源和业务素养，在现代社会是有很多工作机会的；但对自己一定要有高标准，有对更好工作机会的追求热情，这就需要在某些领域技术有深度的积累。今年的特殊环境催生了大量对音视频领域的技术人才需求，而音视频也是经久不衰的技术领域，所以在第四季度我报了一个网络课程，全面深入地学习音视频开发的技术。原本计划今年考研究生，但在下半年由于工作时间比较紧，加上有音视频开发的学习课程，以及更明确地通过平时工作学习积累，导致考研准备不足，所以取消了今年的考研计划，后面再考虑考研的事情。</p>
<h2 id="关于我们家庭">关于我们家庭</h2>
<p>这一年我们成立了自己的小家庭，1月份在我哥的全力帮助下完成了我和老婆的婚礼，亲友们见证了我成家的盛典，这是很多亲人期盼的一天，遗憾的是父亲没有见证这一幕。</p>
<p>5月份的时候，老婆在北京顺利生产了我们的第一个孩子，儿子皓荣出生以及一直到现在的成长都很顺利，这也许是命运对我的福报吧，感激！儿子出生后，丈母娘来北京照顾他们母子俩3月，那时候正是我在家准备面试和刚入职新公司，感谢她的付出！</p>
<p>有了孩子的家庭才更有家的气氛，老婆在家带儿子，我在外上班，有了家的氛围，工作生活都有了劲头。9月初在我们原来租住的房子到期后，我们换了新的住处，独立租了一个两居室，房子离我工作的地方很近，开始两个月还可以每天骑着电瓶车回家吃午饭。10月初，我把我老妈从老家接到北京来住，父亲走了快10年了，她一直想在老家跟哥一家住。她很想跟我一起住住，因为我一直没有成家，在大城市生活不容易，所以一直不能满足她的愿望。现在我结婚成家了，老婆也很有孝心，老妈过来住三个月了，她很喜欢和我们住一起，有老有小的一家是很幸福的家庭！</p>
<h2 id="关于我的国家社会">关于我的国家社会</h2>
<p>2020年必定是被铭记的一年，从年初开始新冠肺炎疫情就给整个国家带来了前所未有的紧张感。一种不明来历的病毒传染很快，对人的生命造成极大的威胁，而在国际上西方国家又一直对我国存有政治和意识形态的偏见，借助这次病毒首先在我国境内大面积传播的问题，以美国为首的西方国家对我国进行无底线的挑衅和打击，在春节期间国内应对疫情的状态有相当多的困难。好在国家治理有方，有条不紊地进行了全面的抗疫，到了天气回暖后的4、5月份，国内疫情初步得到了控制，生产生活有序地逐步恢复展开，全社会逐渐恢复勃勃生机。不过疫情仍然没有被完全控制，由于国外政府管理不利加上国外人民对病毒的轻视，新冠肺炎在欧美国家相继持续爆发了，出现了他们在年初嘲笑和打击的中国面对疫情时的种种问题。7、8月分后，中国不同的地方也偶尔发生一些小规模的疫情爆发问题，不过在中国已经形成了防疫的成熟应对方案，疫情不会发生大范围的如年初那样的失控的状态。</p>
<p>这一年一直有疫情笼罩着全世界，就算在这个最需要人类共同携手解决人类问题的时刻，人类世界中也不能避免政治、经济和意识方面的斗争。美国政府一直对我国的科技企业穷追猛打，华为公司的新产品供货受阻，只好选择整体打包出售其手机产品业务。美国还不忘在中国的主权和内政问题上添油加醋扰乱是非，它们关闭中国的驻美使馆，在香港台湾问题上使乱子，当然日渐强大的中国在适当的时候给了它们正面的回击。</p>
<p>国家社会大事不是我们渺小的个人所能左右的，但我们身在其中，必须要对时事有所了解，对大势有所判断，这些可能间接甚至直接地影响到我们的工作和生活。</p>
<p>2020就此别过吧，2021充满希望，希望祖国山河锦绣、国泰民安，祝愿自己在已有的幸福生活上继续努力，获得更美好的生活！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记部落帖子分享微信小程序封面图片合成的一些坑]]></title>
        <id>https://git4pl.github.io/post/WmBbWgxWB/</id>
        <link href="https://git4pl.github.io/post/WmBbWgxWB/">
        </link>
        <updated>2020-08-22T01:07:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="项目背景">项目背景</h3>
<p>58部落帖子详情的分享功能里分享到微信小程序，原有的封面图是由Server端下发的图片，若帖子是纯文本内容则Server下发的是58部落的广告默认图，这样分享出去的微信小程序封面图形势比较简单。为了丰富小程序封面图的内容，激起收到分享的用户点击进入小程序查看帖子的兴趣，本次项目针对这个小程序封面图进行优化设计。</p>
<p>新版本的分享到小程序的封面图设计是这样的：用帖子的素材合成一副新的封面图，要求封面图的顶部展示用户头像、名称以及帖子的浏览量。根据帖子是否带有图片，合成的封面图有两种不同的样式：<br>
1、带图片的帖子，取帖子第一张图片，在用户信息下面展示图片内容<br>
2、纯文本的帖子，取帖子正文内容展示在用户信息下面，最多显示6行帖子内容<br>
<img src="https://git4pl.github.io/post-images/1598063903913.png" alt="cover with picture" loading="lazy"><br>
<img src="https://git4pl.github.io/post-images/1598063965619.png" alt="cover with text" loading="lazy"></p>
<h3 id="实现方案">实现方案</h3>
<p>由于封面图中的元素都是Server动态下发的，尤其是图片需要下载后才能处理。一开始想到用UI控件来创建这个布局，可以很方便地利用控件的属性实现UI效果的细节，但是要生成的封面图没有Activity或者其他ViewGroup容器来承载它的绘制，最后采用Canvas + Paint来动态绘制，并将生成的Bitmap保存为本地文件。在实现这个UI效果的过程中遇到了一些技术上的小坑，记录下来以备后续复用。</p>
<h4 id="绘制圆形头像">绘制圆形头像</h4>
<p>利用Canvas绘制圆形图是很容易的事，通常可以使用这三种API在Canvas上实现圆形图：BitmapShader、ClipPath和PorterDuffXfermode。</p>
<h5 id="bitmapshager-图片渲染方式">BitmapShager 图片渲染方式</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个BitmapShader对象 使用传递过来的原Bitmap对象bmp
    BitmapShader bitmapShader = new BitmapShader(bmp, Shader.TileMode.CLAMP，Shader.TileMode.CLAMP);
 
    //paint设置shader
    paint.setShader(bitmapShader);
 
    //canvas画一个圆 使用设置了shader的paint
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);
   
    return newBitmap;
}
</code></pre>
<h5 id="clippath-裁剪区域">ClipPath 裁剪区域</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个Path对象，path添加一个圆 圆心半径均是r / 2， Path.Direction.CW顺时针方向
    Path path = new Path();
    path.addCircle(r / 2, r / 2, r / 2, Path.Direction.CW);
    //canvas绘制裁剪区域
    canvas.clipPath(path);   
    //canvas将图画到留下的圆形区域上
    canvas.drawBitmap(bmp, 0, 0, paint);
 
    return newBitmap;
}
</code></pre>
<h5 id="porterduffxfermode-图片混合模式">PorterDuffXfermode 图片混合模式</h5>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);

    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);

    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);

    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);

    //canvas画一个圆形
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);

    //然后 paint要设置Xfermode 模式为SRC_IN 显示上层图像（后绘制的一个）的相交部分
    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));

    //canvas调用drawBitmap直接将bmp对象画在画布上 
    //因为paint设置了Xfermode，所以最终只会显示这个bmp的一部分 
    //也就是bmp的和下层圆形相交的一部分圆形的内容
    canvas.drawBitmap(bmp, 0, 0, paint);

    return newBitmap;
}
</code></pre>
<p>虽然上面三种方式都能绘出圆形图，但在实际项目需求中有一些坑需要注意。<br>
使用BitmapShader要注意图像缩放的处理，可以计算好缩放比例，使用Matrix对象设置缩放比例，然后将Matrix对象设置到BitmapShader对象中。<br>
使用Canvas的clipPath方法设置path，然后调用drawBitmap绘制的图形有锯齿现象，即使在paint中设置了抗锯齿参数也不能消除。<br>
使用Xfermode的方式，在实际项目中如果直接用上面代码里的写法将不能得到预期的圆形图，需要使用saveLayer方法将绘制操作保存到新的图层，将图像合成的处理放到离屏缓存中进行。</p>
<h4 id="文字居中绘制">文字居中绘制</h4>
<p>项目需求中要求顶部的用户头像和用户名水平方向居中对齐，这两者要居中对齐可以确定一个基准参考线，比如都关于顶部栏纵向的中线上下对称，头像关于该中线对称很容易实现，而要实现文字关于该中线的对称需要理解Android绘制文字的原理以及drawText方法的参数意义。<br>
<img src="https://git4pl.github.io/post-images/1598087533894.png" alt="" loading="lazy"><br>
Android的文字绘制是按如上图所示的基线绘制的，与之对应的实现是Paint类中的FontMetrics类的定义。</p>
<pre><code>public static class FontMetrics {
    /**
        * The maximum distance above the baseline for the tallest glyph in
        * the font at a given text size.
        */
    public float   top;
    /**
        * The recommended distance above the baseline for singled spaced text.
        */
    public float   ascent;
    /**
        * The recommended distance below the baseline for singled spaced text.
        */
    public float   descent;
    /**
        * The maximum distance below the baseline for the lowest glyph in
        * the font at a given text size.
        */
    public float   bottom;
    /**
        * The recommended additional space to add between lines of text.
        */
    public float   leading;
}
</code></pre>
<p>drawText()方法的x、y指定要绘制文字的基准点，该基准点是要绘制的文字基准线上的left、center、right三点之一（如下图），具体是哪个由paint的setTextAlign()方法设置，默认是left。<br>
<img src="https://git4pl.github.io/post-images/1598088667357.png" alt="" loading="lazy"><br>
要让所画的文字刚好相对于我们选定的参考线上下居中，即让文字的中心点落在参考线上，我们需要计算调用drawText()方法的y坐标，即上图中基线的y坐标值。可以将问题转化为计算中心点相对于基线的距离，文字中心点相对于其基线的距离可表示为 (top+bottom)/2 - bottom，在屏幕坐标系中top的实际值相对于基线是负数，所以前述距离公式为 (-top+bottom)/2 - bottom，简化后为 -top/2 - bottom/2，将此值加上参考线的y坐标值即为我们所求的y坐标。另外要注意paint.getFontMetrics()这个方法一定要在设置字体大小或者样式等一系列会影响字体的方法后调用，不然获取到的top和bottom值不准。</p>
<pre><code>Paint paint = new Paint();
paint.setTextSize(textSize);
paint.setAntiAlias(true);
Paint.FontMetrics fm = paint.getFontMetrics();
float top = fm.top;
float bottom = fm.bottom;
float baseLineY = (headH &gt;&gt; 1) - top / 2 - bottom / 2;
canvas.drawText(username, x, baseLineY, paint);
</code></pre>
<h4 id="绘制多行文字">绘制多行文字</h4>
<p>Canvas.drawText()只能绘制单行的文字，不能换行。它既不能在View的边缘自动折行显示，也不能在换行符\n处换行。而StaticLayout 支持换行，它既可以为文字设置宽度上限来让文字自动换行，也会在 \n 处主动换行。<br>
StaticLayout通过构造函数参数设置文字显示的属性。StaticLayout 的构造方法是 StaticLayout(CharSequence source, TextPaint paint, int width, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad)，其中参数里：</p>
<pre><code>width 是文字区域的宽度，文字到达这个宽度后就会自动换行；
align 是文字的对齐方向；
spacingmult 是行间距的倍数，通常情况下填 1 就好；
spacingadd 是行间距的额外增加值，通常情况下填 0 就好；
includepad 是指是否在文字上下添加额外的空间，来避免某些过高的字符的绘制出现越界。
</code></pre>
<h4 id="图片裁剪压缩">图片裁剪压缩</h4>
<p>微信分享SDK对分享到微信小程序的封面图大小有限制，要求体积不超过128KB，对图片分辨率没有明确要求，但是在不同机型以及平台终端上展示分享出去的小程序链接里发现微信SDK对封面图的尺寸比例是有要求的。小程序在显示分享的封面图时，图片的宽高比为5:4，不符合这个比例的尺寸，微信客户端将会对其进行裁剪。</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="https://blog.csdn.net/zly921112/article/details/50401976">android canvas drawText()文字居中</a><br>
<a href="https://www.jianshu.com/p/5136fbc0d301">StaticLayout支持文字绘制换行</a><br>
<a href="https://blog.csdn.net/TO_BE_RM/article/details/79859540">初识Android Bitmap压缩原理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Canvas绘制圆形图]]></title>
        <id>https://git4pl.github.io/post/Vgyf9i2nb/</id>
        <link href="https://git4pl.github.io/post/Vgyf9i2nb/">
        </link>
        <updated>2020-08-16T10:35:52.000Z</updated>
        <content type="html"><![CDATA[<p>最近实现一个业务需求，要求将用户头像、用户名和正文内容合成为一张图片，以作为给微信小程序分享的封面图。通过一些ImageView控件是很容易实现圆形头像的，但这里需要创建一块画布，在Canvas上画出圆形头像，如果细节处理不好，可能达不到理想的效果。<br>
通常用Java代码绘制圆形图有三种方法，分别是使用BitmapShader、PorterDuffXfermode和ClipPath。这里记录一下这三种画圆形图的代码实现：</p>
<h4 id="bitmapshager-图片渲染方式">BitmapShager 图片渲染方式</h4>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个BitmapShader对象 使用传递过来的原Bitmap对象bmp
    BitmapShader bitmapShader = new BitmapShader(bmp, Shader.TileMode.CLAMP，Shader.TileMode.CLAMP);
 
    //paint设置shader
    paint.setShader(bitmapShader);
 
    //canvas画一个圆 使用设置了shader的paint
    canvas.drawCircle(r / 2, r / 2, r / 2, paint);
   
    return newBitmap;
}
</code></pre>
<h4 id="porterduffxfermode-图片混合模式">PorterDuffXfermode 图片混合模式</h4>
<pre><code>    public Bitmap getCirleBitmap(Bitmap bmp) {
        //获取bmp的宽高 小的一个做为圆的直径r
        int w = bmp.getWidth();
        int h = bmp.getHeight();
        int r = Math.min(w, h);
 
        //创建一个paint
        Paint paint = new Paint();
        paint.setAntiAlias(true);
 
        //新创建一个Bitmap对象newBitmap 宽高都是r
        Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
        //创建一个使用newBitmap的Canvas对象
        Canvas canvas = new Canvas(newBitmap);
 
        //canvas画一个圆形
        canvas.drawCircle(r / 2, r / 2, r / 2, paint);
 
        //然后 paint要设置Xfermode 模式为SRC_IN 显示上层图像（后绘制的一个）的相交部分
        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
 
        //canvas调用drawBitmap直接将bmp对象画在画布上 
        //因为paint设置了Xfermode，所以最终只会显示这个bmp的一部分 
        //也就是bmp的和下层圆形相交的一部分圆形的内容
        canvas.drawBitmap(bmp, 0, 0, paint);
 
        return newBitmap;
    }
</code></pre>
<h4 id="clippath-裁剪区域">ClipPath 裁剪区域</h4>
<pre><code>public Bitmap getCirleBitmap(Bitmap bmp) {
    //获取bmp的宽高 小的一个做为圆的直径r
    int w = bmp.getWidth();
    int h = bmp.getHeight();
    int r = Math.min(w, h);
 
    //创建一个paint
    Paint paint = new Paint();
    paint.setAntiAlias(true);
 
    //新创建一个Bitmap对象newBitmap 宽高都是r
    Bitmap newBitmap = Bitmap.createBitmap(r, r, Bitmap.Config.ARGB_8888);
 
    //创建一个使用newBitmap的Canvas对象
    Canvas canvas = new Canvas(newBitmap);
 
    //创建一个Path对象，path添加一个圆 圆心半径均是r / 2， Path.Direction.CW顺时针方向
    Path path = new Path();
    path.addCircle(r / 2, r / 2, r / 2, Path.Direction.CW);
    //canvas绘制裁剪区域
    canvas.clipPath(path);   
    //canvas将图画到留下的圆形区域上
    canvas.drawBitmap(bmp, 0, 0, paint);
 
    return newBitmap;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于类加载的时机与过程]]></title>
        <id>https://git4pl.github.io/post/OH92heMH4/</id>
        <link href="https://git4pl.github.io/post/OH92heMH4/">
        </link>
        <updated>2020-07-19T02:54:31.000Z</updated>
        <content type="html"><![CDATA[<p>思考以下代码的输出结果：</p>
<pre><code>public class Singleton {
    private static Singleton instance = new Singleton();
    public static int count1;
    public static int count2 = 0;
    private Singleton() {
        count1 ++;
        count2 ++;
    }

    public static Singleton getInstance() {
        return instance;
    }
｝

public class Test {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println(&quot;count1 = &quot; + Singleton.count1);
        System.out.println(&quot;count2 = &quot; + Singleton.count2);
    }
}
</code></pre>
<blockquote>
<p>错误答案<br>
count1 = 1<br>
count2 = 1</p>
</blockquote>
<blockquote>
<p>正确答案<br>
count1 = 1<br>
count2 = 0</p>
</blockquote>
<p>这个问题就是牵涉到类的加载与过程，虚拟机定义了以下六种情况，如果类未被初始化，则会进行初始化：<br>
1、创建类的实例<br>
2、访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。<br>
3、访问类的静态方法<br>
4、反射如(Class.forName(&quot;my.xyz.Test&quot;))<br>
5、当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化<br>
6、虚拟机启动时，定义了main()方法的那个类先初始化</p>
<p>我们来分析以下上述代码的执行情况：</p>
<ol>
<li>main()方法 Test类初始化</li>
<li>main()方法第一句：访问Singleton的getInstance()静态方法 Singleton类初始化，此时按照代码执行顺序进行静态成员的初始化默认值<br>
instance = null<br>
count1 = 0<br>
count2 = 0</li>
<li>按照代码执行顺序为类的静态成员赋值：<br>
private static Singleton instance = new Singleton(); instance调用Singleton的构造方法,调用构造方法后 count1 = 1,count2 = 1<br>
public static int count1; count1没有进行赋值操作，所以count1 = 1<br>
public static int count2 = 0; count2进行赋值操作，所以count2 = 0</li>
<li>main()方法第二句：访问Singleton的count1变量，由于count1没有赋初始值，所以count1 = 1</li>
<li>main()方法第三句：访问Singleton的count2变量，由于count2赋了初始值 0，所以count2 = 0</li>
</ol>
<p>如果我们把Singleton代码执行顺序变化一下：</p>
<pre><code>public class Singleton {
    public static int count1;
    public static int count2 = 0;
    private static Singleton instance = new Singleton();

    private Singleton() {
        count1++;
        count2++;
    }

    public static Singleton getInstance() {
        return instance;
    }

}
</code></pre>
<p>此时输出结果就为:</p>
<blockquote>
<p>count1 = 1<br>
count2 = 1</p>
</blockquote>
<p>如果改为如下代码，那么运行情况又是怎样：</p>
<pre><code>public class Singleton {
    Singleton(){
        System.out.println(&quot;Singleton construct&quot;);
    }

    static {
        System.out.println(&quot;Singleton static block&quot;);
    }

    public static final int COUNT = 1;

}

public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;count = &quot; + Singleton.COUNT);
    }
}
</code></pre>
<p>运行结果为：</p>
<blockquote>
<p>count = 1</p>
</blockquote>
<p>由于常量在编译阶段会存入相应类的常量池当中，所以在实际调用中Singleton.COUNT并没有直接引用到Singleton类，因此不会进行Singleton类的初始化，所以输出结果为 count = 1</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="https://www.jianshu.com/p/27eb533b29f7">Kotlin:由object和companion object创建的单例模式引发的思考</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式笔记]]></title>
        <id>https://git4pl.github.io/post/NUANIynJT/</id>
        <link href="https://git4pl.github.io/post/NUANIynJT/">
        </link>
        <updated>2020-07-11T01:28:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="开篇小引">开篇小引</h3>
<p>在上大学时我做了一个小项目是关于人机交互的应用，我负责实现的部分是通过语音识别技术接收用户的问题，然后在数据库中检索预置的问题答案，并由我们的应用“说”出来对用户的问题进行解答。当时我就由这个应用的交互模式产生了一个小小的想法，我希望有一天可以实现一个很简单方便的东西能让中国的老奶奶和美国甚至更多其他国家的老奶奶坐在一起轻松愉快地聊天，完全不用担心各自语言的障碍，这涉及到语音识别和机器翻译等诸多技术，现在顶级的科技公司已经在各种细分的技术上有研究实践了。我的那个小想法其实与本篇博客的主题——适配器模式——有相似的实现思想。</p>
<h3 id="定义及特点">定义及特点</h3>
<p><strong>适配器模式将一个类的接口转换成客户期望的另一个接口，使得原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</strong></p>
<p>适配器模式可以通过创建适配器进行接口转换，让不兼容的接口变得能兼容。这可以让客户从实现的接口解耦，如果在一段时间之后，我们想要改变接口，适配器可以将改变的部分封装起来，客户端就不必为了应对不同的接口而每次跟着修改。</p>
<p>适配器模式涉及到三种角色：<br>
●  目标接口（Target）——定义客户期望的与特定领域相关的接口<br>
●  适配者类（Adaptee）——定义一个已经存在的接口，是需要适配的类<br>
●  适配器类（Adapter）——通过包装一个需要适配的对象，把原接口转换成目标接口</p>
<h3 id="适用场景">适用场景</h3>
<p>以下情况可使用适配器模式：<br>
√  系统需要使用现有的类，而这些类的接口不符合系统的接口<br>
√  想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作<br>
√  两个类所做的事情相同或相似，但是具有不同接口的时候<br>
√  旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候<br>
√  使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能</p>
<h3 id="实现方式">实现方式</h3>
<p>在GoF的设计模式中，适配器模式有两种可行的实现方式：<strong>类适配器</strong>和<strong>对象适配器</strong>，类适配器使用多重继承对一个接口与另一个接口进行匹配，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431276853.png" alt="" loading="lazy"><br>
对象适配器依赖于对象组合，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431299777.webp" alt="" loading="lazy"><br>
类适配器因为需要Adapter类同时继承自Target类和Adaptee类，所以只能在支持多重继承的语言中实现（Java虽然不支持多继承，但可以通过实现接口implements interface来实现类适配器，如下代码示例）；对象适配器模式充满着良好的OO设计原则：使用对象组合，以修改的接口包装被适配者，这样被适配者的任何子类，都可以搭配着适配器使用。</p>
<pre><code>public interface Target {
    /**
     * 这是适配者类Adaptee也有的方法
     */
    public void sampleOperation1(); 
    /**
     * 这是适配者类Adapteee没有的方法
     */
    public void sampleOperation2(); 
}

public class Adaptee {
    void sampleOperation1(){}
}

public class Adapter extends Adaptee implements Target {
    /**
     * 由于适配者类Adaptee没有方法sampleOperation2()
     * 因此适配器类Adapter补充上这个方法
     */
    @Override
    public void sampleOperation2() {
        //实现相关的代码
    }
}
</code></pre>
<p>类适配器和对象适配器有不同的权衡。<br>
类适配器：<br>
●  用一个具体的Adapter类对Adaptee和Target进行匹配，这使得Adapter不能和Adaptee的子类一起工作<br>
●  使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的子类<br>
●  仅仅引入了一个对象，并不需要额外的指针以间接得到Adaptee<br>
对象适配器：<br>
●  允许一个Adapter与多个Adaptee（即Adaptee本身以及它的所有子类）同时工作，Adapter也可以一次给所有的Adaptee添加功能<br>
●  重定义Adaptee的行为比较困难（这需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身）</p>
<h3 id="适配器小结">适配器小结</h3>
<p>使用适配器的优点：<br>
1、通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。<br>
2、复用了现存的类，解决了现存类和复用环境要求不一致的问题。<br>
3、将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。<br>
4、一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>
<p>使用适配器的缺点：<br>
过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p>
<h3 id="thanks-to">Thanks To</h3>
<p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/09/2582485.html">设计模式学习笔记-适配器模式</a><br>
<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">《JAVA与模式》之适配器模式</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[真的理解单例模式吗？]]></title>
        <id>https://git4pl.github.io/post/TjHrGm886/</id>
        <link href="https://git4pl.github.io/post/TjHrGm886/">
        </link>
        <updated>2020-07-07T12:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>单例模式是设计模式中最常用也最简单的一种模式，相信很多程序员小伙伴在求职面试过程中都被面试官问到过单例模式。虽然它的定义和类结构非常简单，但是要实现一个完全没有问题的单例模式却没有那么简单；即使能写出一个合格有效的单例模式，要把其中的逻辑原理讲述清楚令面试官满意也不容易。</p>
<p>单例模式的实现方式有很多种，不同的实现方式能适应不同的应用场景。单线程中的单例比较简单，单例模式的复杂性主要是在多线程并发环境下要充分考虑对象访问的性能、线程安全等问题。如何实现高性能、线程安全、防攻击的单例模式？对于线程安全的单例实现方式，它们分别是怎样保证线程安全的？DCL的单例实现中synchronized和volatile关键字分别有什么作用？带着这些问题我再深入学习一下单例模式。</p>
<h3 id="定义及特点">定义及特点</h3>
<p>单例模式确保一个类只有一个实例，并提供一个全局访问方法。其类结构图如下：<br>
<img src="https://git4pl.github.io/post-images/1594123603857.jpeg" alt="" loading="lazy"></p>
<p>单例模式是对象创建型模式，要实现一个单例类需满足以下几个要素：<br>
（1） 一个私有的构造方法<br>
（2） 一个指向自己实例的私有的静态引用<br>
（3） 一个返回自己实例的公有的静态方法<br>
所以一个单例类应该类似下面的伪代码：</p>
<pre><code>public class Singleton {
    private Singleton() {} //私有的构造方法
    private static Singleton singleton; //指向自己实例的私有静态引用
    public static Singleton getInstance() { //返回自己实例的公有静态方法
        …… //创建本单例类的唯一实例，并赋值给私有静态引用
        return singleton;
    }
}
</code></pre>
<p>其实，按照定义的方式写出的单例模式并不能保证单例对象的唯一，可以通过以下方法破坏一个单例类的实例唯一性：</p>
<ul>
<li>使用反射，虽然构造器为非公开，但是在反射面前就不起作用了。</li>
<li>如果单例的类实现了cloneable，那么还是可以拷贝出多个实例的。</li>
<li>Java中的对象序列化也有可能导致创建多个实例。</li>
<li>使用多个类加载器加载单例类，也会导致创建多个实例并存的问题。</li>
</ul>
<p>所以，如果要考虑单例类的防攻击，在实现时还需要做到防止反序列化、防止反射、防止克隆。</p>
<pre><code>//readResolve method to preserve Singleton property
private Object readResolve() throws ObjectStreamException {
    return INSTANCE;
}

//防止反射调用后创建新的Singleton实例
private static boolean flag = false;  
private Singleton() {
    synchronized(Singleton.class) {
        if (!flag) {
            flag = true;  
        } else {  
            throw new RuntimeException(&quot;单例模式被侵犯！&quot;);  
        }  
    }  
}

//防止克隆产生新的实例
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException(&quot;Cannot clone instance of this class&quot;);
}
</code></pre>
<p>因为单例类对象的生命周期是从实例被创建到应用程序结束，所以一个高质量的单例类还需要满足以下特点：<br>
√ 懒加载    ——  在需要时才创建单例类的实例<br>
√ 线程安全 —— 应保证在多线程环境下访问单例类不会创建多个实例<br>
√ 高性能    —— 获取单例对象的过程中应减少同步的消耗</p>
<h3 id="适用场景">适用场景</h3>
<p>由于单例类保证一个类只有一个实例，并且由此表现出了一些其他优点，使得单例模式是在开发中比较常用的一种设计模式。根据单例类的优点，单例模式通常适用于以下场景的类创建：<br>
● 需要频繁实例化然后销毁的对象<br>
● 创建对象时耗时过多或者耗资源过多，但又经常用到的对象<br>
● 有状态的工具类对象<br>
● 频繁访问数据库或文件的对象<br>
● 需要保证数据一致性的配置文件类或工具类对象</p>
<h3 id="实现方式">实现方式</h3>
<p>根据单例模式的思想以及单例类能解决的问题，单例模式的实现方式有多种，不同的实现方式可能在单例对象的实例化时机、线程安全性和访问性能方面有所不同。下面分别整理各种实现方式及其优缺点。</p>
<h4 id="饿汉式单例">饿汉式单例</h4>
<pre><code>public class Singleton {  
    private static Singleton instance=new Singleton();  
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;  
    }
} 
</code></pre>
<p>这种单例实现方法之所以被称为饿汉式是因为它利用JVM机制在单例类被加载时实例化。其实例化时机比较早，所以没有实现懒加载（Lazy Loading），即使这个实例在应用的生命周期内没有被使用到，也会因为已经被加载而占用一定的内存空间；另外这种实现方式也无法给单例的实例化过程传入必须的参数。饿汉式的实现方式比较简单，在单例类被加载到内存时就完成了实例化，避免了线程同步的问题；另外因为实例没有被使用而造成的内存浪费问题可以忽略，饿汉式单例的实现方式是被推荐使用的。<br>
饿汉式单例的实例化过程还有一种写法，不过本质上也是利用JVM的类加载机制，只是语法的应用而已，如下：</p>
<pre><code>private static Singleton instance = null;  
static {  
   instance = new Singleton();  
}
</code></pre>
<h4 id="懒汉式单例">懒汉式单例</h4>
<p>懒汉式单例的实现目的就是为了达到单例类的懒加载，即在单例类第一次被使用到的时候实例化该单例类，对应到单例类实现的基本要素就是在返回单例类实例的公有静态方法中去实例化单例对象。懒汉式单例的最直接最简单的实现如下：</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
<p>上述实现方式在实际项目中并不可取，因为它存在线程安全问题，当有多个线程去调用getInstance()方法获取Singleton的实例时，有可能得到的不是同一个对象，即有可能每个线程访问getInstance()方法时各自创建一个Singleton实例。要解决这种实现方式的线程安全问题，可以考虑加锁进行同步。</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {};
    public static synchronized Singleton getInstance() {
        if (instance == null) {
	    instance = new Singleton();
	}
	
        return instance;
    }
}
</code></pre>
<p>上面的改进是在getInstance()方法上加锁进行同步，这样虽然解决了线程安全的问题，但又带来了访问效率低下的问题。每个线程在访问getInstance()方法获得类实例的时候，都要进行同步操作，而其实这个方法只需执行一次实例化代码就够了，只要单例对象还存在就可以直接return给访问者。对懒汉式单例进一步优化得到了既能保证线程安全又能有较高的访问效率的<strong>双重检查锁(Double Checked Locking)实现</strong>。</p>
<h4 id="双重检测的单例">双重检测的单例</h4>
<pre><code>public class Singleton {
    private static volatile Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance(){
         if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
    }
}
</code></pre>
<p>双重检查锁的实现方式是比较健壮的懒汉式单例实现，有两个问题需要理解：<br>
1、双重检查有什么意义<br>
双重检查就是在getInstance()方法中有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检查一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检查的话就会生成多个实例了。<br>
假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p>
<p>2、静态引用instance前的volatile关键字有何作用<br>
主要在于instance = new Singleton();这句并非是一个原子操作，在JVM中这句话大概做了下面 3 件事情：<br>
① 分配一块内存空间M<br>
② 调用 Singleton 的构造函数在内存M上创建对象<br>
③ 将M的地址赋值给 instance 变量（执行完这步 instance 就为非 null 了）<br>
但是在JVM的即时编译器中存在指令重排序的优化，也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 ①-②-③ 也可能是 ①-③-②。如果是后者，则在 ③ 执行完毕、② 未执行之前，线程二执行到同步快外的检查，这时 instance 已经是非 null 了，所以线程二会直接返回 instance，但却没有完成初始化。<br>
<img src="https://git4pl.github.io/post-images/1603974948705.png" alt="" loading="lazy"></p>
<p>volatile 修饰符具有禁止指令重排序优化的特性，也就是说在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 ①-②-③ 或者 ①-③-② 之后，不存在执行到 ①-③ 然后取到值的情况。从「先行发生原则（happens-before）」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<h4 id="静态内部类实现单例">静态内部类实现单例</h4>
<pre><code>public class Singleton{
    private Singleton() {}
    private static class SingletonHolder{
        private static Singleton instance=new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
</code></pre>
<p>通过在类中创建一个静态内部类来实现单例模式也是利用了JVM的类加载机制保证只创建一份实例，同时与饿汉式单例一样具有线程安全性，而且客户在获取这个单例类实例的时候不会进行同步，没有性能缺陷，也不依赖 JDK 版本。静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时调getInstance()方法，才会装载SingletonHolder类实例化Singleton，这样就实现了单例类的懒加载。<br>
由于使用静态内部类实现单例避免了线程不安全的问题，并且有较高的访问效率以及实现了延迟加载，这种方式是值得推荐的单例实现方式，当然这种方式与饿汉式单例一样不能传入参数。</p>
<h4 id="枚举实现单例">枚举实现单例</h4>
<pre><code>public enum Singleton {
    INSTANCE;
    private Singleton() {}
    public void method() {
    }
 }
</code></pre>
<p>从Java1.5版本起，创建单例可以使用简洁的枚举类型，我们直接通过Singleton.INSTANCE来访问实例。对于枚举类型，编译器会自动帮我们创建一个final类型的类继承自Enum类，并且该类中的几个属性被定义成static final，在static代码块中初始化那些属性，枚举类型通过Java类加载机制和初始化过程保证线程安全；而且通过jvm规范保证序列化，枚举还能防止反序列化或者反射攻击导致创建新的实例。《Effective Java》中更是说明单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<h3 id="kotlin单例实现">Kotlin单例实现</h3>
<p>用Kotlin语言实现单例模式很简单，使用object关键字代替class关键字定义的类就是一个单例类。</p>
<pre><code>object Singleton {
    fun sayHello() {
        Log.d(&quot;TAG&quot;, &quot;Hello Kotlin&quot;)
    }

    init {
        Log.d(&quot;TAG&quot;, &quot;initialize the Kotlin class&quot;)
    }
}
</code></pre>
<p>将Kotlin实现的单例类的字节码转成Java代码，如下图：<br>
<img src="https://wos.58cdn.com.cn/IjGfEdCbIlr/ishare/e38f8dd9-af69-42be-ad30-1fa51ee77ef2kotlin_singleton.png" alt="kotlin_singleton.png" loading="lazy"></p>
<p>可见，上面的Kotlin单例类对应的Java代码其实是Java版本的饿汉式单例。单例对象在静态代码块中创建，单例类的静态引用被定义成public static final，因为在Java代码中访问这个单例对象时会调用它。如下分别是Kotlin和Java代码访问这个单例的方法：</p>
<pre><code>//Kotlin 调用
Singleton.sayHello()

//Java 调用
Singleton.INSTANCE.sayHello();
</code></pre>
<p>用object关键字声明的单例类无法给单例的实例化过程传入参数，可借助Kotlin的伴生对象companion object来实现带参数的单例，因为伴生对象中的方法和属性被绑定到类上，通过类名直接访问，它将在类被加载的时候初始化。</p>
<p>如下用伴生对象带参数实现双重检测的单例类：</p>
<pre><code>class Singleton private constructor(context: Context) {
    companion object {
        @Volatile
        private var instance: Singleton? = null
        fun getInstance(context: Context): Singleton {
            if (instance != null) {
                return instance as Singleton
            }

            return synchronized(this) {
                if (instance != null) {
                    instance as Singleton
                } else {
                    val created = Singleton(context)
                    instance = created
                    created
                }
            }
        }
    }
}
</code></pre>
<p>利用companion object还可以实现其他类型的单例模式的Kotlin版本。</p>
<h3 id="单例模式小结">单例模式小结</h3>
<p>单例模式是类结构和模式思想最简单的一种设计模式，也是实际项目在被使用最多的一种模式，Android SDK的许多类以及许多第三方开源库都提供了很多有单例行为的类。单例模式的实现方式有多种，但在实际使用时需要认真考量单例类的线程安全性、访问效率和懒加载属性，所有的限制和设计都要保证Singleton类仅仅被实例化一次。</p>
<h3 id="thanks-to">Thanks To:</h3>
<p><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">如何正确地写出单例模式</a><br>
<a href="http://blog.csdn.net/dmk877/article/details/50311791">Java设计模式—单例设计模式(Singleton Pattern)完全解析</a><br>
<a href="http://blog.csdn.net/zhengzhb/article/details/7331354">单例模式讨论篇：单例模式与垃圾回收</a><br>
<a href="https://blog.csdn.net/wufaliang003/article/details/81395411">Java中枚举的线程安全性及序列化问题</a><br>
<a href="https://juejin.im/post/6844903590545326088#heading-12">Kotlin下的5种单例模式</a></p>
]]></content>
    </entry>
</feed>