<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://git4pl.github.io</id>
    <title>PL Notes</title>
    <updated>2020-07-11T02:02:50.403Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://git4pl.github.io"/>
    <link rel="self" href="https://git4pl.github.io/atom.xml"/>
    <subtitle>积跬步至千里，积小流成江海</subtitle>
    <logo>https://git4pl.github.io/images/avatar.png</logo>
    <icon>https://git4pl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, PL Notes</rights>
    <entry>
        <title type="html"><![CDATA[适配器模式笔记]]></title>
        <id>https://git4pl.github.io/post/NUANIynJT/</id>
        <link href="https://git4pl.github.io/post/NUANIynJT/">
        </link>
        <updated>2020-07-11T01:28:47.000Z</updated>
        <content type="html"><![CDATA[<p>###开篇小引<br>
在上大学时我做了一个小项目是关于人机交互的应用，我负责实现的部分是通过语音识别技术接收用户的问题，然后在数据库中检索预置的问题答案，并由我们的应用“说”出来对用户的问题进行解答。当时我就由这个应用的交互模式产生了一个小小的想法，我希望有一天可以实现一个很简单方便的东西能让中国的老奶奶和美国甚至更多其他国家的老奶奶坐在一起轻松愉快地聊天，完全不用担心各自语言的障碍，这涉及到语音识别和机器翻译等诸多技术，现在顶级的科技公司已经在各种细分的技术上有研究实践了。我的那个小想法其实与本篇博客的主题——适配器模式——有相似的实现思想。<br>
###定义及特点<br>
<strong>适配器模式将一个类的接口转换成客户期望的另一个接口，使得原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</strong></p>
<p>适配器模式可以通过创建适配器进行接口转换，让不兼容的接口变得能兼容。这可以让客户从实现的接口解耦，如果在一段时间之后，我们想要改变接口，适配器可以将改变的部分封装起来，客户端就不必为了应对不同的接口而每次跟着修改。</p>
<p>适配器模式涉及到三种角色：<br>
●  目标接口（Target）——定义客户期望的与特定领域相关的接口<br>
●  适配者类（Adaptee）——定义一个已经存在的接口，是需要适配的类<br>
●  适配器类（Adapter）——通过包装一个需要适配的对象，把原接口转换成目标接口</p>
<p>###适用场景<br>
以下情况可使用适配器模式：<br>
√  系统需要使用现有的类，而这些类的接口不符合系统的接口<br>
√  想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作<br>
√  两个类所做的事情相同或相似，但是具有不同接口的时候<br>
√  旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候<br>
√  使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能</p>
<p>###实现方式<br>
在GoF的设计模式中，适配器模式有两种可行的实现方式：<strong>类适配器</strong>和<strong>对象适配器</strong>，类适配器使用多重继承对一个接口与另一个接口进行匹配，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431276853.png" alt="" loading="lazy"><br>
对象适配器依赖于对象组合，如下图所示<br>
<img src="https://git4pl.github.io/post-images/1594431299777.webp" alt="" loading="lazy"><br>
类适配器因为需要Adapter类同时继承自Target类和Adaptee类，所以只能在支持多重继承的语言中实现（Java虽然不支持多继承，但可以通过实现接口implements interface来实现类适配器，如下代码示例）；对象适配器模式充满着良好的OO设计原则：使用对象组合，以修改的接口包装被适配者，这样被适配者的任何子类，都可以搭配着适配器使用。</p>
<pre><code>public interface Target {
    /**
     * 这是适配者类Adaptee也有的方法
     */
    public void sampleOperation1(); 
    /**
     * 这是适配者类Adapteee没有的方法
     */
    public void sampleOperation2(); 
}

public class Adaptee {
    void sampleOperation1(){}
}

public class Adapter extends Adaptee implements Target {
    /**
     * 由于适配者类Adaptee没有方法sampleOperation2()
     * 因此适配器类Adapter补充上这个方法
     */
    @Override
    public void sampleOperation2() {
        //实现相关的代码
    }
}
</code></pre>
<p>类适配器和对象适配器有不同的权衡。<br>
类适配器：<br>
●  用一个具体的Adapter类对Adaptee和Target进行匹配，这使得Adapter不能和Adaptee的子类一起工作<br>
●  使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的子类<br>
●  仅仅引入了一个对象，并不需要额外的指针以间接得到Adaptee<br>
对象适配器：<br>
●  允许一个Adapter与多个Adaptee（即Adaptee本身以及它的所有子类）同时工作，Adapter也可以一次给所有的Adaptee添加功能<br>
●  重定义Adaptee的行为比较困难（这需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身）</p>
<p>###适配器小结<br>
使用适配器的优点：<br>
1、通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。<br>
2、复用了现存的类，解决了现存类和复用环境要求不一致的问题。<br>
3、将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。<br>
4、一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>
<p>使用适配器的缺点：<br>
过多的使用适配器，会让系统非常零乱，不易整体进行把握。</p>
<p>###Thanks To<br>
<a href="http://www.cnblogs.com/wangjq/archive/2012/07/09/2582485.html">设计模式学习笔记-适配器模式</a><br>
<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">《JAVA与模式》之适配器模式</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[真的理解单例模式吗？]]></title>
        <id>https://git4pl.github.io/post/TjHrGm886/</id>
        <link href="https://git4pl.github.io/post/TjHrGm886/">
        </link>
        <updated>2020-07-07T12:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>单例模式是设计模式中最常用也最简单的一种模式，相信很多程序员小伙伴在求职面试过程中都被面试官问到过单例模式。虽然它的定义和类结构非常简单，但是要实现一个完全没有问题的单例模式却没有那么简单；即使能写出一个合格有效的单例模式，要把其中的逻辑原理讲述清楚令面试官满意也不容易。</p>
<p>单例模式的实现方式有很多种，不同的实现方式能适应不同的应用场景。单线程中的单例比较简单，单例模式的复杂性主要是在多线程并发环境下要充分考虑对象访问的性能、线程安全等问题。如何实现高性能、线程安全、防攻击的单例模式？对于线程安全的单例实现方式，它们分别是怎样保证线程安全的？DCL的单例实现中synchronized和volatile关键字分别有什么作用？带着这些问题我再深入学习一下单例模式。</p>
<h3 id="定义及特点">定义及特点</h3>
<p>单例模式确保一个类只有一个实例，并提供一个全局访问方法。其类结构图如下：<br>
<img src="https://git4pl.github.io/post-images/1594123603857.jpeg" alt="" loading="lazy"></p>
<p>单例模式是对象创建型模式，要实现一个单例类需满足以下几个要素：<br>
（1） 一个私有的构造方法<br>
（2） 一个指向自己实例的私有的静态引用<br>
（3） 一个返回自己实例的公有的静态方法<br>
所以一个单例类应该类似下面的伪代码：</p>
<pre><code>public class Singleton {
    private Singleton() {} //私有的构造方法
    private static Singleton singleton; //指向自己实例的私有静态引用
    public static Singleton getInstance() { //返回自己实例的公有静态方法
        …… //创建本单例类的唯一实例，并赋值给私有静态引用
        return singleton;
    }
}
</code></pre>
<p>另外，如果要考虑单例类的防攻击，在实现时还需要做到防止反序列化、防止反射、防止克隆。</p>
<pre><code>//readResolve method to preserve Singleton property
private Object readResolve() throws ObjectStreamException {
    return INSTANCE;
}

//防止反射调用后创建新的Singleton实例
private static boolean flag = false;  
private Singleton() {
    synchronized(Singleton.class) {
        if (!flag) {
            flag = true;  
        } else {  
            throw new RuntimeException(&quot;单例模式被侵犯！&quot;);  
        }  
    }  
}

//防止克隆产生新的实例
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException(&quot;Cannot clone instance of this class&quot;);
}
</code></pre>
<p>因为单例类对象的生命周期是从实例被创建到应用程序结束，所以一个高质量的单例类还需要满足以下特点：<br>
√ 懒加载    ——  在需要时才创建单例类的实例<br>
√ 线程安全 —— 应保证在多线程环境下访问单例类不会创建多个实例<br>
√ 高性能    —— 获取单例对象的过程中应减少同步的消耗</p>
<h3 id="适用场景">适用场景</h3>
<p>由于单例类保证一个类只有一个实例，并且由此表现出了一些其他优点，使得单例模式是在开发中比较常用的一种设计模式。根据单例类的优点，单例模式通常适用于以下场景的类创建：<br>
● 需要频繁实例化然后销毁的对象<br>
● 创建对象时耗时过多或者耗资源过多，但又经常用到的对象<br>
● 有状态的工具类对象<br>
● 频繁访问数据库或文件的对象<br>
● 需要保证数据一致性的配置文件类或工具类对象</p>
<h3 id="实现方式">实现方式</h3>
<p>根据单例模式的思想以及单例类能解决的问题，单例模式的实现方式有多种，不同的实现方式可能在单例对象的实例化时机、线程安全性和访问性能方面有所不同。下面分别整理各种实现方式及其优缺点。</p>
<h4 id="饿汉式单例">饿汉式单例</h4>
<pre><code>public class Singleton {  
    private static Singleton instance=new Singleton();  
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;  
    }
} 
</code></pre>
<p>这种单例实现方法之所以被称为饿汉式是因为它利用JVM机制在单例类被加载时实例化。其实例化时机比较早，所以没有实现懒加载（Lazy Loading），即使这个实例在应用的生命周期内没有被使用到，也会因为已经被加载而占用一定的内存空间；另外这种实现方式也无法给单例的实例化过程传入必须的参数。饿汉式的实现方式比较简单，在单例类被加载到内存时就完成了实例化，避免了线程同步的问题；另外因为实例没有被使用而造成的内存浪费问题可以忽略，饿汉式单例的实现方式是被推荐使用的。<br>
饿汉式单例的实例化过程还有一种写法，不过本质上也是利用JVM的类加载机制，只是语法的应用而已，如下：</p>
<pre><code>private static Singleton instance = null;  
static {  
   instance = new Singleton();  
}
</code></pre>
<h4 id="懒汉式单例">懒汉式单例</h4>
<p>懒汉式单例的实现目的就是为了达到单例类的懒加载，即在单例类第一次被使用到的时候实例化该单例类，对应到单例类实现的基本要素就是在返回单例类实例的公有静态方法中去实例化单例对象。懒汉式单例的最直接最简单的实现如下：</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre>
<p>上述实现方式在实际项目中并不可取，因为它存在线程安全问题，当有多个线程去调用getInstance()方法获取Singleton的实例时，有可能得到的不是同一个对象，即有可能每个线程访问getInstance()方法时各自创建一个Singleton实例。要解决这种实现方式的线程安全问题，可以考虑加锁进行同步。</p>
<pre><code>public class Singleton {
    private static Singleton instance=null;
    private Singleton() {};
    public static synchronized Singleton getInstance() {
        if (instance == null) {
	    instance = new Singleton();
	}
	
        return instance;
    }
}
</code></pre>
<p>上面的改进是在getInstance()方法上加锁进行同步，这样虽然解决了线程安全的问题，但又带来了访问效率低下的问题。每个线程在访问getInstance()方法获得类实例的时候，都要进行同步操作，而其实这个方法只需执行一次实例化代码就够了，只要单例对象还存在就可以直接return给访问者。对懒汉式单例进一步优化得到了既能保证线程安全又能有较高的访问效率的<strong>双重检查锁(Double Checked Locking)实现</strong>。</p>
<h4 id="双重检测的单例">双重检测的单例</h4>
<pre><code>public class Singleton {
    private static volatile Singleton instance=null;
    private Singleton() {}
    public static Singleton getInstance(){
         if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
    }
}
</code></pre>
<p>双重检查锁的实现方式是比较健壮的懒汉式单例实现，有两个问题需要理解：<br>
1、双重检查有什么意义<br>
双重检查就是在getInstance()方法中有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检查一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检查的话就会生成多个实例了。<br>
2、静态引用instance前的volatile关键字有何作用<br>
主要在于instance = new Singleton();这句并非是一个原子操作，在JVM中这句话大概做了下面 3 件事情：<br>
① 给 instance 分配内存<br>
② 调用 Singleton 的构造函数来初始化成员变量<br>
③ 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）<br>
但是在JVM的即时编译器中存在指令重排序的优化，也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 ①-②-③ 也可能是 ①-③-②。如果是后者，则在 ③ 执行完毕、② 未执行之前，线程二执行到同步快外的检查，这时 instance 已经是非 null 了，所以线程二会直接返回 instance，但却没有完成初始化。<br>
volatile 修饰符具有禁止指令重排序优化的特性，也就是说在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 ①-②-③ 或者 ①-③-② 之后，不存在执行到 ①-③ 然后取到值的情况。从「先行发生原则（happens-before）」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<h4 id="静态内部类实现单例">静态内部类实现单例</h4>
<pre><code>public class Singleton{
    private Singleton() {}
    private static class SingletonHolder{
        private static Singleton instance=new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
</code></pre>
<p>通过在类中创建一个静态内部类来实现单例模式也是利用了JVM的类加载机制保证只创建一份实例，同时与饿汉式单例一样具有线程安全性，而且客户在获取这个单例类实例的时候不会进行同步，没有性能缺陷，也不依赖 JDK 版本。静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时调getInstance()方法，才会装载SingletonHolder类实例化Singleton，这样就实现了单例类的懒加载。<br>
由于使用静态内部类实现单例避免了线程不安全的问题，并且有较高的访问效率以及实现了延迟加载，这种方式是值得推荐的单例实现方式，当然这种方式与饿汉式单例一样不能传入参数。</p>
<h4 id="枚举实现单例">枚举实现单例</h4>
<pre><code>public enum Singleton {
    INSTANCE;
    private Singleton() {}
    public void method() {
    }
 }
</code></pre>
<p>从Java1.5版本起，创建单例可以使用简洁的枚举类型，我们直接通过Singleton.INSTANCE来访问实例。对于枚举类型，编译器会自动帮我们创建一个final类型的类继承自Enum类，并且该类中的几个属性被定义成static final，在static代码块中初始化那些属性，枚举类型通过Java类加载机制和初始化过程保证线程安全；而且通过jvm规范保证序列化，枚举还能防止反序列化或者反射攻击导致创建新的实例。《Effective Java》中更是说明单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<h3 id="单例模式小结">单例模式小结</h3>
<p>单例模式是类结构和模式思想最简单的一种设计模式，也是实际项目在被使用最多的一种模式，Android SDK的许多类以及许多第三方开源库都提供了很多有单例行为的类。单例模式的实现方式有多种，但在实际使用时需要认真考量单例类的线程安全性、访问效率和懒加载属性，所有的限制和设计都要保证Singleton类仅仅被实例化一次。</p>
<h3 id="thanks-to">Thanks To:</h3>
<p><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">如何正确地写出单例模式</a><br>
<a href="http://blog.csdn.net/dmk877/article/details/50311791">Java设计模式—单例设计模式(Singleton Pattern)完全解析</a><br>
<a href="http://blog.csdn.net/zhengzhb/article/details/7331354">单例模式讨论篇：单例模式与垃圾回收</a><br>
<a href="https://blog.csdn.net/wufaliang003/article/details/81395411">Java中枚举的线程安全性及序列化问题</a></p>
]]></content>
    </entry>
</feed>